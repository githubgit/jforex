/*
 * Copyright 2009 DukascopyÂ® (Suisse) SA. All rights reserved.
 * DUKASCOPY PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
package com.dukascopy.api;

import java.io.File;
import java.util.Collection;

import com.dukascopy.api.feed.IFeedDescriptor;
import com.dukascopy.api.feed.IFeedInfo;
import com.dukascopy.api.indicators.IIndicator;
import com.dukascopy.api.indicators.IIndicatorCalculator;
import com.dukascopy.api.instrument.IFinancialInstrument;

/**
 * Contains a set of functions to calculate indicator data
 *
 * @author Dmitry Shohov
 * 
 * @see <a href = http://www.dukascopy.com/wiki/#Strategy_API:_Indicators>Strategy API: Indicators</a>
 */
public interface IIndicators {

	/**
     * Used to specify which price to use for indicator calculation
     * 
     * @author Dmitry Shohov
     */
    public enum AppliedPrice {
        /**
         * Close price
         */
        CLOSE("Close price"),
        /**
         * Open price
         */
        OPEN("Open price"),
        /**
         * High price
         */
        HIGH("High price"),
        /**
         * Low price
         */
        LOW("Low price"),
        /**
         * Median price (HL/2)
         */
        MEDIAN_PRICE("Median price (HL/2)"),
        /**
         * Typical price (HLC/3)
         */
        TYPICAL_PRICE("Typical price (HLC/3)"),
        /**
         * Weighted close price (HLCC/4)
         */
        WEIGHTED_CLOSE("Weighted close price (HLCC/4)"),
        /**
         * Date and time of bar
         */
        TIMESTAMP("Time"),
        /**
         * Volume of bar
         */
        VOLUME("Volume");
        
        private final String text;
        
        private AppliedPrice(String text) {
            this.text = text;
        }
        
        @Override
        public String toString() {
            return text;
        }
    }
    
    /**
     * Types of Moving Average
     * 
     * @author Dmitry Shohov
     */
    public enum MaType {
        /**
         * Simple Moving Average
         */
        SMA,
        /**
         * Exponential Moving Average
         */
        EMA,
        /**
         * Weighted Moving Average
         */
        WMA,
        /**
         * Double Exponential Moving Average
         */
        DEMA,
        /**
         * Triple Exponential Moving Average
         */
        TEMA,
        /**
         * Triangular Moving Average
         */
        TRIMA,
        /**
         * Kaufman Adaptive Moving Average
         */
        KAMA,
        /**
         * MESA Adaptive Moving Average
         */
        MAMA,
        /**
         * T3 Moving Average
         */
        T3,
        /**
         * Hull Moving Average
         */
        HMA,
        /**
         * Linear Weighted Moving Average
         */
        LWMA,
        /**
         * Smoothed Moving Average
         */
        SMMA
    }
    
    /**
     * Returns a list of indicator groups
     * 
     * @return a list of indicator groups
     */
    public Collection<String> getGroups();
    
    /**
     * Returns indicator names that belong to the specified group
     * 
     * @param groupName indicator group
     * @return indicator names
     */
    public Collection<String> getNames(String groupName);
    
    /**
     * Returns a list of all indicator names
     * 
     * @return a list of all indicator names
     */
    public Collection<String> getAllNames();
    
    /**
     * Returns the indicator with the specified name
     * 
     * @param name name of the indicator
     * @return indicator
     */
    public IIndicator getIndicator(String name);

    /**
     * Return the indicator that is located at specified path
     *
     * @param indicatorPath path to indicator jfx file
     * @return indicator
     */
    public IIndicator getIndicatorByPath(String indicatorPath);
    
    /**
     * Attempts to open and register a custom indicator in the system. If operation is successful then the indicator will appear in
     * the list returned by the {@link #getAllNames()} method and can be called by {@link #calculateIndicator } functions
	 *
     *
     * @param compiledCustomIndcatorFile file with the compiled indicator (the one with .jfx extension)
     * @return the name of registered indicator
     * @throws JFException when indicator does not exist or can not be instantiated or does not pass the validation
     * 
     */
    public String registerCustomIndicator(File compiledCustomIndcatorFile) throws JFException;

    /**
	 * Register custom indicator by class
	 *
	 * @param indicatorClass - indicator class must implement the {@link IIndicator} interface
	 * @return the name of registered indicator
	 * @throws JFException in case of any error
	 */
    public String registerCustomIndicator(Class<? extends IIndicator> indicatorClass) throws JFException;
    
    /**
     * Attempts to open and register a downloadable indicator in the system. If operation is successful then the indicator will appear in
     * the list returned by the {@link #getAllNames()} method and can be called by {@link #calculateIndicator } functions
     *
     * @param id indicator version identifier
     * @param name name of the indicator
     * @throws JFException when the given indicator version does not exist or can not be downloaded or can not be instantiated or does not pass the validation
     */
    public void registerDownloadableIndicator(String id, String name) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, 1);
     * double min = (Double)(result[0]);
     * double max = (Double)(result[1]);
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *     Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *     new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, 1);
     * double min = (Double)(result[0]);
     * double max = (Double)(result[1]);
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, 1);
     * double obv = (Double)(result[0]);
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, 1);
     * double obv = (Double)(result[0]);
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, 1);
     * double min = (Double)(result[0]);
     * double max = (Double)(result[1]);
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, 1);
     * double min = (Double)(result[0]);
     * double max = (Double)(result[1]);
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, Filter.ALL_FLATS, 1);
     * double obv = (Double)(result[0]);
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bar
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the indicator
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of doubles or integers for every indicator output.
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, 1);
     * double min = (Double)(result[0]);
     * double max = (Double)(result[1]);
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators. 
     * 
     * @param instrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param from start time of the first bar
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b> 
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * long from = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 2).getTime(); 
	 * long to = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
	 *	    
	 * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
	 *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
	 *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, from, to);
	 *		
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre> 
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, long from, long to) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param from start time of the first bar
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * long from = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
     * long to = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, from, to);
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, long from, long to) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bars
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param from start time of the first bar
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * long from = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
	 * long to = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
	 *
	 * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
	 *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
	 *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, from, to);
	 *
     * double obvFrom = ((double[])result[0])[0];
     * double obvTo = ((double[])result[0])[1];
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, long from, long to) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument bar instrument
     * @param period bar period
     * @param offerSides Bid or Ask side of the bars
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param from start time of the first bar
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * long from = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
     * long to = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, from, to);
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, long from, long to) throws JFException;

    /**
     * This is a universal function that allows to get values for any indicator available including user indicators.
     *
     * @param instrument instrument of the bars
     * @param period period of the bars
     * @param offerSides bid or ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param from start time of the first bar that should be included in calculation
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * long timeFrom = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
	 * long timeTo = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
	 *
	 * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
	 *  	Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
	 *  	new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, timeFrom, timeTo);
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, Filter filter, long from, long to) throws JFException;

    /**
     * This is a universal function that allows to get values for any indicator available including user indicators.
     *
     * @param financialInstrument instrument of the bars
     * @param period period of the bars
     * @param offerSides bid or ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param from start time of the first bar that should be included in calculation
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * long timeFrom = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
     * long timeTo = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
     *  	Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *  	new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, timeFrom, timeTo);
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, long from, long to) throws JFException;

    /**
     * This is a universal function that allows to get values for any indicator available including user indicators.
     *
     * @param instrument instrument of the bars
     * @param period period of the bars
     * @param offerSides bid or ask side of the bars
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param from start time of the first bar that should be included in calculation
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * long timeFrom = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
	 * long timeTo = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
	 *
	 * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
	 *  	Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
	 *  	new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, Filter.ALL_FLATS, timeFrom, timeTo);
     *
     * double obvFrom = ((double[])result[0])[0];
     * double obvTo = ((double[])result[0])[1];
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, Filter filter, long from, long to) throws JFException;

    /**
     * This is a universal function that allows to get values for any indicator available including user indicators.
     *
     * @param financialInstrument instrument of the bars
     * @param period period of the bars
     * @param offerSides bid or ask side of the bars
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param from start time of the first bar that should be included in calculation
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * long timeFrom = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
     * long timeTo = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *  	Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *  	new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, timeFrom, timeTo);
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, long from, long to) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param instrument instrument of the bars
     * @param period period of the bars
     * @param offerSides Bid or Ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param numberOfCandlesBefore how much candles to load before and including candle with time specified in <code>time</code> parameter
     * @param time time of the last candles in period specified in <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior first candle in period specified with <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (not including) candle with time specified in <code>time</code> parameter
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a> 
     * <p>
     * <b>Note:</b> 
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * long time = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime(); 
     *		
     * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, 2, time, 0);
     *		 
	 * double minFrom = ((double[])result[0])[0];
	 * double maxFrom = ((double[])result[1])[0];
	 * double minTo = ((double[])result[0])[1];
	 * double maxTo = ((double[])result[1])[1];
     * </pre>  
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument instrument of the bars
     * @param period period of the bars
     * @param offerSides Bid or Ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param numberOfCandlesBefore how much candles to load before and including candle with time specified in <code>time</code> parameter
     * @param time time of the last candles in period specified in <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior first candle in period specified with <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (not including) candle with time specified in <code>time</code> parameter
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * long time = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, Filter.ALL_FLATS, 2, time, 0);
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param instrument instrument of the bars
     * @param period period of the bars
     * @param offerSides Bid or Ask side of the bars
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param numberOfCandlesBefore how much candles to load before and including candle with time specified in <code>time</code> parameter
     * @param time time of the last candles in period specified in <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior first candle in period specified with <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (not including) candle with time specified in <code>time</code> parameter
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * long time = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(Instrument.EURUSD,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, Filter.ALL_FLATS, 2, time, 0);
     *
	 * double obvFrom = ((double[])result[0])[0];
	 * double obvTo = ((double[])result[0])[1];
     * </pre>
     */
    public Object[] calculateIndicator(Instrument instrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available, including user indicators.
     *
     * @param financialInstrument instrument of the bars
     * @param period period of the bars
     * @param offerSides Bid or Ask side of the bars
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param filter {@link Filter filter} allows to filter candles
     * @param numberOfCandlesBefore how much candles to load before and including candle with time specified in <code>time</code> parameter
     * @param time time of the last candles in period specified in <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior first candle in period specified with <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (not including) candle with time specified in <code>time</code> parameter
     * @return array of arrays of doubles or integers for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     *
     * long time = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(financialInstrument,
     *      Period.ONE_HOUR, new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, Filter.ALL_FLATS, 2, time, 0);
     *
     * double obvFrom = ((double[])result[0])[0];
     * double obvTo = ((double[])result[0])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFinancialInstrument financialInstrument, Period period, OfferSide[] offerSides, Period basePeriod, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     *
     * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator.
     * The function does not use filter set in feedDescriptor and no filtration is applied during calculation.
     * @param offerSides bid or ask side of the bar
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * FeedDescriptor feedDescriptor = new FeedDescriptor();
     *
     * feedDescriptor.setDataType(DataType.TIME_PERIOD_AGGREGATION);
     * feedDescriptor.setFilter(Filter.NO_FILTER);
     * feedDescriptor.setInstrument(Instrument.EURUSD);
     * feedDescriptor.setPeriod(Period.ONE_HOUR);
     *
     * Object[] result = indicators.calculateIndicator(feedDescriptor,
     *      new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, 1);
     *
     * double min = (Double)(result[0]);
     * double max = (Double)(result[1]);
     * </pre>
     */
    public Object[] calculateIndicator(IFeedDescriptor feedDescriptor, OfferSide[] offerSides, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     *
     * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator.
     * The function does not use filter set in feedDescriptor and no filtration is applied during calculation.
     * @param offerSides bid or ask side of the bar
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * FeedDescriptor feedDescriptor = new FeedDescriptor();
     *
     * feedDescriptor.setDataType(DataType.TIME_PERIOD_AGGREGATION);
     * feedDescriptor.setFilter(Filter.NO_FILTER);
     * feedDescriptor.setInstrument(Instrument.EURUSD);
     * feedDescriptor.setPeriod(Period.ONE_HOUR);
     *
     * Object[] result = indicators.calculateIndicator(feedDescriptor,
     *      new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, 1);
     *
     * double obv = (Double)(result[0]);
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFeedDescriptor feedDescriptor, OfferSide[] offerSides, Period basePeriod, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     *
     * @param feedInfo feed info {@link com.dukascopy.api.feed.IFeedInfo} that will be used to calculate indicator.
     * The function does not use filter set in feedInfo and no filtration is applied during calculation.
     * @param offerSides bid or ask side of the bar
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     * IFeedInfo feedInfo = context.getFeedInfoProvider().createTimePeriodFeedInfo(
     *     financialInstrument, OfferSide.BID, Period.ONE_MIN, Filter.ALL_FLATS);
     *
     * Object[] result = indicators.calculateIndicator(feedInfo,
     *      new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, 1);
     *
     * double min = (Double)(result[0]);
     * double max = (Double)(result[1]);
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFeedInfo feedInfo, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, int shift) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators. 
     * 
     * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator 
     * @param offerSides bid or ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param from start time of the first bar
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b> 
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * FeedDescriptor feedDescriptor = new FeedDescriptor();
     * 		
     * feedDescriptor.setDataType(DataType.TIME_PERIOD_AGGREGATION);		
     * feedDescriptor.setFilter(Filter.NO_FILTER);
     * feedDescriptor.setInstrument(Instrument.EURUSD);
     * feedDescriptor.setPeriod(Period.ONE_HOUR);
     * 		
     * long timeFrom = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 2).getTime(); 
	 * long timeTo = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
	 * 		
	 * Object[] result = indicators.calculateIndicator(feedDescriptor, 
	 *      new OfferSide[] {OfferSide.ASK}, "MINMAX",
	 *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, timeFrom, timeTo);
	 * 			 
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>  
     */
    public Object[] calculateIndicator(IFeedDescriptor feedDescriptor, OfferSide[] offerSides, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, long from, long to) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     *
     * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
     * @param offerSides bid or ask side of the bars
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param from start time of the first bar
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * FeedDescriptor feedDescriptor = new FeedDescriptor();
     *
     * feedDescriptor.setDataType(DataType.TIME_PERIOD_AGGREGATION);
     * feedDescriptor.setFilter(Filter.NO_FILTER);
     * feedDescriptor.setInstrument(Instrument.EURUSD);
     * feedDescriptor.setPeriod(Period.ONE_HOUR);
     *
     * long timeFrom = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
	 * long timeTo = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
	 *
	 * Object[] result = indicators.calculateIndicator(feedDescriptor,
	 *      new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
	 *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, timeFrom, timeTo);
	 *
     * double obvFrom = ((double[])result[0])[0];
     * double obvTo = ((double[])result[0])[1];
     * </pre>
     */
    public Object[] calculateIndicator(IFeedDescriptor feedDescriptor, OfferSide[] offerSides, Period basePeriod, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, long from, long to) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     *
     * @param feedInfo feed info {@link IFeedInfo} which will be used to calculate indicator
     * @param offerSides bid or ask side of the bars
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param from start time of the first bar
     * @param to start time of the last bar that should be included in calculation
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     * IFeedInfo feedInfo = context.getFeedInfoProvider().createTimePeriodFeedInfo(
     *     financialInstrument, OfferSide.BID, Period.ONE_MIN, Filter.ALL_FLATS);
     *
     * long timeFrom = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 2).getTime();
     * long timeTo = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(feedInfo,
     *      new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, timeFrom, timeTo);
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFeedInfo feedInfo, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, long from, long to) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     * 
     * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator 
     * @param offerSides bid or ask side of the bar
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param numberOfBarsBefore how much candles to load before and including bar with time specified in <code>time</code> parameter
     * @param time of the last bar in period specified in <code>numberOfBarsBefore</code> parameter or/and
     *        time of the bar prior to the first bar in period specified with <code>numberOfBarsAfter</code> parameter
     * @param numberOfBarsAfter how much bars to load after (not including) bar with time specified in <code>time</code> parameter
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b> 
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * FeedDescriptor feedDescriptor = new FeedDescriptor();
     * 		
     * feedDescriptor.setDataType(DataType.TIME_PERIOD_AGGREGATION);		
     * feedDescriptor.setFilter(Filter.NO_FILTER);
     * feedDescriptor.setInstrument(Instrument.EURUSD);
     * feedDescriptor.setPeriod(Period.ONE_HOUR);
     * 		
     * long time = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime(); 
     * 		
     * Object[] result = indicators.calculateIndicator(feedDescriptor, 
     *      new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, 2, time, 0);
     * 
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];		
     * </pre>   
     */
    public Object[] calculateIndicator(IFeedDescriptor feedDescriptor, OfferSide[] offerSides, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, int numberOfBarsBefore, long time, int numberOfBarsAfter) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     *
     * @param feedInfo feed info {@link com.dukascopy.api.feed.IFeedInfo} that will be used to calculate indicator.
     * @param offerSides bid or ask side of the bar
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param numberOfBarsBefore how much candles to load before and including bar with time specified in <code>time</code> parameter
     * @param time of the last bar in period specified in <code>numberOfBarsBefore</code> parameter or/and
     *        time of the bar prior to the first bar in period specified with <code>numberOfBarsAfter</code> parameter
     * @param numberOfBarsAfter how much bars to load after (not including) bar with time specified in <code>time</code> parameter
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     *
     * IFinancialInstrumentProvider instrumentProvider = context.getFinancialInstrumentProvider();
     * IFinancialInstrument financialInstrument = instrumentProvider.getFinancialInstrument("EUR/USD");
     * IFeedInfo feedInfo = context.getFeedInfoProvider().createTimePeriodFeedInfo(
     *     financialInstrument, OfferSide.BID, Period.ONE_MIN, Filter.ALL_FLATS);
     *
     * long time = history.getBar(financialInstrument, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(feedInfo,
     *      new OfferSide[] {OfferSide.ASK}, "MINMAX",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{5}, 2, time, 0));
     *
     * double minFrom = ((double[])result[0])[0];
     * double maxFrom = ((double[])result[1])[0];
     * double minTo = ((double[])result[0])[1];
     * double maxTo = ((double[])result[1])[1];
     * </pre>
     */
    @Deprecated
    public Object[] calculateIndicator(IFeedInfo feedInfo, OfferSide[] offerSides, String functionName,
            AppliedPrice[] inputTypes, Object[] optParams, int numberOfBarsBefore, long time, int numberOfBarsAfter) throws JFException;

    /**
     * This is a universal function that allows getting values for any indicator available based on any {@link DataType} supported by JForex, including user indicators.
     *
     * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
     * @param offerSides bid or ask side of the bar
     * @param basePeriod base period for unstable period indicators
     * <br><br>
     * <table border="1">
     * <caption>Available base periods for different calculation periods</caption>
     * <tr><th>Base period</th><th>Min calc. period</th><th>Max calc. period</th></tr>
     * <tr><td>1 Min</td><td>-</td><td>10 Sec</td></tr>
     * <tr><td>10 Min</td><td>-</td><td>1 Min</td></tr>
     * <tr><td>1 Hour</td><td>10 Sec</td><td>10 Min</td></tr>
     * <tr><td>4 Hours</td><td>20 Sec</td><td>1 Hour</td></tr>
     * <tr><td>1 Day</td><td>5 Min</td><td>4 Hours</td></tr>
     * <tr><td>1 Week</td><td>15 Min</td><td>1 Day</td></tr>
     * <tr><td>1 Month</td><td>1 Hour</td><td>1 Week</td></tr>
     * </table>
     * @param functionName name of the function
     * @param inputTypes {@link IIndicators.AppliedPrice type} of the input data for every input that indicator requires or null if input is PRICE
     * @param optParams array of optional parameters consisting of Doubles and Integers
     * @param numberOfBarsBefore how much candles to load before and including bar with time specified in <code>time</code> parameter
     * @param time of the last bar in period specified in <code>numberOfBarsBefore</code> parameter or/and
     *        time of the bar prior to the first bar in period specified with <code>numberOfBarsAfter</code> parameter
     * @param numberOfBarsAfter how much bars to load after (not including) bar with time specified in <code>time</code> parameter
     * @return array of arrays of doubles, integers or objects for every indicator output
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * <p>
     * <b>Note:</b>
     * type conversion may be used in order to work with the result of indicator calculation. For example,
     * <pre>
     * FeedDescriptor feedDescriptor = new FeedDescriptor();
     *
     * feedDescriptor.setDataType(DataType.TIME_PERIOD_AGGREGATION);
     * feedDescriptor.setFilter(Filter.NO_FILTER);
     * feedDescriptor.setInstrument(Instrument.EURUSD);
     * feedDescriptor.setPeriod(Period.ONE_HOUR);
     *
     * long time = history.getBar(Instrument.EURUSD, Period.ONE_HOUR, OfferSide.ASK, 1).getTime();
     *
     * Object[] result = indicators.calculateIndicator(feedDescriptor,
     *      new OfferSide[] {OfferSide.ASK, OfferSide.ASK}, Period.MONTHLY, "OBV",
     *      new AppliedPrice[]{AppliedPrice.CLOSE}, new Object[]{}, 2, time, 0);
     *
     * double obvFrom = ((double[])result[0])[0];
     * double obvTo = ((double[])result[0])[1];
     * </pre>
     */
    public Object[] calculateIndicator(IFeedDescriptor feedDescriptor, OfferSide[] offerSides, Period basePeriod, String functionName,
    		AppliedPrice[] inputTypes, Object[] optParams, int numberOfBarsBefore, long time, int numberOfBarsAfter) throws JFException;

    /**
     * Calculates the Vector Trigonometric ACos for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double acos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric ACos for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     *      
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] acos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric ACos for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] acos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric ACos for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     *      
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter} 
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] acos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Accelerator/Decelerator Oscillator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #ac2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, int shift)}
     */
    public double[] ac(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, int shift) throws JFException;

    /**
     * Calculates the Accelerator/Decelerator Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #ac2(Instrument instrument, Period period, OfferSide side,  AppliedPrice appliedPrice, int fastPeriod, int slowPeriod,  long from, long to)}
     */
    public double[][] ac(Instrument instrument, Period period, OfferSide side,  AppliedPrice appliedPrice, int fastPeriod, int slowPeriod,  long from, long to) throws JFException;

    /**
     * Calculates the Accelerator/Decelerator Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #ac2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] ac(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Accelerator/Decelerator Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #ac2(Instrument instrument, Period period, OfferSide side,  AppliedPrice appliedPrice, int fastPeriod, int slowPeriod,  Filter filter, long from, long to)}
     */
    public double[][] ac(Instrument instrument, Period period, OfferSide side,  AppliedPrice appliedPrice, int fastPeriod, int slowPeriod,  Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Accelerator/Decelerator Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ac2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, int shift) throws JFException;
    
    /**
     * Calculates the Accelerator/Decelerator Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. The resulting array for ticks is an array of values for 1 second bars.
     *     
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ac2(Instrument instrument, Period period, OfferSide side,  AppliedPrice appliedPrice, int fastPeriod, int slowPeriod,  long from, long to) throws JFException;
    
    /**
     * Calculates the Accelerator/Decelerator Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ac2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Accelerator/Decelerator Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument bar instrument
     * @param period bar period
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period
     * @param slowPeriod slow period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ac2(Instrument instrument, Period period, OfferSide side,  AppliedPrice appliedPrice, int fastPeriod, int slowPeriod,  Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Chaikin A/D Line for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ad(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Chaikin A/D Line for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ad(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Chaikin A/D Line for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ad(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Chaikin A/D Line for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ad(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Add for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double add(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int shift) throws JFException;

    /**
     * Calculates the Vector Arithmetic Add for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
	 * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] add(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Add for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     ** @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] add(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Arithmetic Add for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] add(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Chaikin A/D Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double adOsc(Instrument instrument, Period period, OfferSide side, int fastPeriod, int slowPeriod, int shift) throws JFException;

    /**
     * Calculates the Chaikin A/D Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adOsc(Instrument instrument, Period period, OfferSide side, int fastPeriod, int slowPeriod, long from, long to) throws JFException;

    /**
     * Calculates the Chaikin A/D Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adOsc(Instrument instrument, Period period, OfferSide side, int fastPeriod, int slowPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Chaikin A/D Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adOsc(Instrument instrument, Period period, OfferSide side, int fastPeriod, int slowPeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Average Directional Movement Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double adx(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Average Directional Movement Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adx(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Average Directional Movement Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adx(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Average Directional Movement Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adx(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Average Directional Movement Index Rating for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double adxr(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Average Directional Movement Index Rating for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adxr(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Average Directional Movement Index Rating for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adxr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Average Directional Movement Index Rating for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] adxr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Alligator indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Alligator Jaw', 'Alligator Teeth', 'Alligator Lips'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Alligator>Alligator indicator</a>
     */    
    public double[] alligator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, int shift) throws JFException;

    /**
     * Calculates the Alligator indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Alligator Jaw', 'Alligator Teeth', 'Alligator Lips' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Alligator>Alligator indicator</a>
     */
    public double[][] alligator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Alligator indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Alligator Jaw', 'Alligator Teeth', 'Alligator Lips' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Alligator>Alligator indicator</a>
     */
    public double[][] alligator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Alligator indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Alligator Jaw', 'Alligator Teeth', 'Alligator Lips' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Alligator>Alligator indicator</a>
     */
    public double[][] alligator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Absolute Price Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param maType moving average type
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double apo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Absolute Price Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param maType moving average type
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] apo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the Absolute Price Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param maType moving average type
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] apo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Absolute Price Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod fast period value
     * @param slowPeriod slow period value
     * @param maType moving average type
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] apo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Aroon indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Aroon Down', 'Aroon Up'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] aroon(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Aroon indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Aroon Down', 'Aroon Up' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] aroon(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Aroon indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Aroon Down', 'Aroon Up' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] aroon(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Aroon indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Aroon Down', 'Aroon Up' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] aroon(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Aroon Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double aroonOsc(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Aroon Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] aroonOsc(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Aroon Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] aroonOsc(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Aroon Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] aroonOsc(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric ASin for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double asin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric ASin for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] asin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric ASin for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] asin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric ASin for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] asin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric ATan for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double atan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric ATan for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] atan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric ATan for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] atan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric ATan for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] atan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Average True Range for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double atr(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Average True Range for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] atr(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Average True Range for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] atr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Average True Range for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] atr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Average Price for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Average_Price>Average Price</a>
     */
    public double avgPrice(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Average_Price>Average Price</a>
     */
    public double[] avgPrice(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Average Price for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Average_Price>Average Price</a>
     */
    public double[] avgPrice(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.s
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Average_Price>Average Price</a>
     */
    public double[] avgPrice(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Awesome Oscillator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Zero', 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, int shift)}
     */
    public double[] awesome(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, int shift) throws JFException;

    /**
     * Calculates the Awesome Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Zero', 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, long from, long to)}
     */
    public double[][] awesome(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, long from, long to) throws JFException;

    /**
     * Calculates the Awesome Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Zero', 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] awesome(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Awesome Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Zero', 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, Filter filter, long from, long to)}
     */
    public double[][] awesome(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Awesome Oscillator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Values', 'Zero'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, int shift) throws JFException;

    /**
     * Calculates the Awesome Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Values', 'Zero'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, long from, long to) throws JFException;

    /**
     * Calculates the Awesome Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Values', 'Zero'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Awesome Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fasterMaTimePeriod faster moving average time period
     * @param fasterMaType faster moving average {@link IIndicators.MaType type}
     * @param slowerMaTimePeriod slower moving average time period
     * @param slowerMaType slower moving average {@link IIndicators.MaType type}
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Values', 'Zero'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] awesome2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Bollinger Bands indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDevUp number of standard deviations up
     * @param nbDevDn number of standard deviations down
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Upper Band', 'Middle Band', 'Lower Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Bollinger_Bands>Bollinger Bands indicator</a>
     */
    public double[] bbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDevUp, double nbDevDn, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Bollinger Bands indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDevUp number of standard deviations up
     * @param nbDevDn number of standard deviations down
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Upper Band', 'Middle Band', 'Lower Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Bollinger_Bands>Bollinger Bands indicator</a>
     */
    public double[][] bbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDevUp, double nbDevDn, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the Bollinger Bands indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDevUp number of standard deviations up
     * @param nbDevDn number of standard deviations down
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Upper Band', 'Middle Band', 'Lower Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Bollinger_Bands>Bollinger Bands indicator</a>
     */
    public double[][] bbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDevUp, double nbDevDn, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Bollinger Bands indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDevUp number of standard deviations up
     * @param nbDevDn number of standard deviations down
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Upper Band', 'Middle Band', 'Lower Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Bollinger_Bands>Bollinger Bands indicator</a>
     */
    public double[][] bbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDevUp, double nbDevDn, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Beta indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Beta>Beta indicator</a>
     */
    public double beta(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Beta indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Beta>Beta indicator</a>
     */
    public double[] beta(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Beta indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Beta>Beta indicator</a>
     */
    public double[] beta(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Beta indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Beta>Beta indicator</a>
     */
    public double[] beta(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Bear Power indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double bear(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Bear Power indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bear(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Bear Power indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bear(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Bear Power indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bear(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Bull Power indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double bull(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Bull Power indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bull(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Bull Power indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bull(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Bull Power indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bull(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Butterworth Filter indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Butterworth>Butterworth Filter indicator</a>
     */
    public double  butterworthFilter(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Butterworth Filter indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Butterworth>Butterworth Filter indicator</a>
     */
    public double[] butterworthFilter(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Butterworth Filter indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Butterworth>Butterworth Filter indicator</a>
     */
    public double[] butterworthFilter(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Butterworth Filter indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Butterworth>Butterworth Filter indicator</a>
     */
    public double[] butterworthFilter(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Market Facilitation Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order:  'MFI Up, Volume Up', 'MFI Down, Volume Down', 
     * 'MFI Up, Volume Down', 'MFI Down, Volume Up'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Market_Facilitation_Index>Market Facilitation Index</a>
     */    
    public double[] bwmfi(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Market Facilitation Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order:  'MFI Up, Volume Up', 'MFI Down, Volume Down', 
     * 'MFI Up, Volume Down', 'MFI Down, Volume Up' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Market_Facilitation_Index>Market Facilitation Index</a>
     */
    public double[][] bwmfi(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Market Facilitation Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order:  'MFI Up, Volume Up', 'MFI Down, Volume Down', 
     * 'MFI Up, Volume Down', 'MFI Down, Volume Up' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Market_Facilitation_Index>Market Facilitation Index</a>
     */
    public double[][] bwmfi(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Market Facilitation Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order:  'MFI Up, Volume Up', 'MFI Down, Volume Down', 
     * 'MFI Up, Volume Down', 'MFI Down, Volume Up' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Market_Facilitation_Index>Market Facilitation Index</a>
     */
    public double[][] bwmfi(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Balance Of Power indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double bop(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Balance Of Power indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bop(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Balance Of Power indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bop(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Balance Of Power indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] bop(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift)}
     */
    public double[] camPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to)}
     */
    public double[][] camPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] camPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to)}
     */
    public double[][] camPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot2(Instrument instrument, Period period, OfferSide side, int shift)}
     */
    public double[] camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot2(Instrument instrument, Period period, OfferSide side, long from, long to)}
     */
    public double[][] camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)',
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #camPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to)}
     */
    public double[][] camPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Camarilla Pivot Points for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] camPivot2(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] camPivot2(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Camarilla Pivot Points for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] camPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Camarilla Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 
     * 'Resistance (R3)', 'Support (S3)', 'Resistance (R4)', 'Support (S4)', 'Resistance (R5)', 'Support (S5)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] camPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Commodity Channel Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double cci(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Commodity Channel Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cci(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Commodity Channel Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cci(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Commodity Channel Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cci(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Two Crows indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdl2Crows(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Two Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl2Crows(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Two Crows indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl2Crows(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Two Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl2Crows(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Three Black Crows indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdl3BlackCrows(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Three Black Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3BlackCrows(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Three Black Crows indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3BlackCrows(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Three Black Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3BlackCrows(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Three Inside Up/Down indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdl3Inside(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Three Inside Up/Down indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3Inside(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Three Inside Up/Down indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3Inside(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Three Inside Up/Down indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3Inside(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Three-Line Strike indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdl3LineStrike(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Three-Line Strike indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3LineStrike(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Three-Line Strike indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3LineStrike(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Three-Line Strike indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3LineStrike(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Three Outside Up/Down indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdl3Outside(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Three Outside Up/Down indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3Outside(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Three Outside Up/Down indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3Outside(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Three Outside Up/Down indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3Outside(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Three Stars In The South indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdl3StarsInSouth(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Three Stars In The South indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3StarsInSouth(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Three Stars In The South indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3StarsInSouth(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Three Stars In The South indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3StarsInSouth(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Three Advancing White Soldiers indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdl3WhiteSoldiers(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Three Advancing White Soldiers indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3WhiteSoldiers(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Three Advancing White Soldiers indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3WhiteSoldiers(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Three Advancing White Soldiers indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdl3WhiteSoldiers(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Abandoned Baby indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration percentage of penetration of a candle within another candle
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlAbandonedBaby(Instrument instrument, Period period, OfferSide side, double penetration, int shift) throws JFException;

    /**
     * Calculates the Abandoned Baby indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration percentage of penetration of a candle within another candle
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlAbandonedBaby(Instrument instrument, Period period, OfferSide side, double penetration, long from, long to) throws JFException;

    /**
     * Calculates the Abandoned Baby indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlAbandonedBaby(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Abandoned Baby indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlAbandonedBaby(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Advance Block indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlAdvanceBlock(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Advance Block indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlAdvanceBlock(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Advance Block indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlAdvanceBlock(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Advance Block indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlAdvanceBlock(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Belt-hold indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlBeltHold(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Belt-hold indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bare
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlBeltHold(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Belt-hold indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlBeltHold(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Belt-hold indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlBeltHold(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Breakaway indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlBreakAway(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Breakaway indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlBreakAway(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Breakaway indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlBreakAway(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Breakaway indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlBreakAway(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Closing Marubozu indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlClosingMarubozu(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Closing Marubozu indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlClosingMarubozu(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Closing Marubozu indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlClosingMarubozu(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Closing Marubozu indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlClosingMarubozu(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Concealing Baby Swallow indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlConcealBabySwall(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Concealing Baby Swallow indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlConcealBabySwall(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Concealing Baby Swallow indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlConcealBabySwall(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Concealing Baby Swallow indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlConcealBabySwall(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Counterattack indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlCounterattack(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Counterattack indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlCounterattack(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Counterattack indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlCounterattack(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Counterattack indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlCounterattack(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Dark Cloud Cover indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlDarkCloudCover(Instrument instrument, Period period, OfferSide side, double penetration, int shift) throws JFException;

    /**
     * Calculates the Dark Cloud Cover indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDarkCloudCover(Instrument instrument, Period period, OfferSide side, double penetration, long from, long to) throws JFException;

    /**
     * Calculates the Dark Cloud Cover indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDarkCloudCover(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Dark Cloud Cover indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDarkCloudCover(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Doji indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlDoji(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDoji(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Doji indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDoji(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDoji(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Doji Star indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlDojiStar(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Doji Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDojiStar(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Doji Star indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDojiStar(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Doji Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDojiStar(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Dragonfly Doji indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlDragonflyDoji(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Dragonfly Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDragonflyDoji(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Dragonfly Doji indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDragonflyDoji(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Dragonfly Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlDragonflyDoji(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Engulfing Pattern indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlEngulfing(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Engulfing Pattern indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEngulfing(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Engulfing Pattern indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEngulfing(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Engulfing Pattern indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEngulfing(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Evening Doji Star indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlEveningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, int shift) throws JFException;

    /**
     * Calculates the Evening Doji Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEveningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, long from, long to) throws JFException;

    /**
     * Calculates the Evening Doji Star indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEveningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Evening Doji Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEveningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Evening Star indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlEveningStar(Instrument instrument, Period period, OfferSide side, double penetration, int shift) throws JFException;

    /**
     * Calculates the Evening Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEveningStar(Instrument instrument, Period period, OfferSide side, double penetration, long from, long to) throws JFException;

    /**
     * Calculates the Evening Star indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEveningStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Evening Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlEveningStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Up/Down-gap side-by-side white lines indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlGapSideSideWhite(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Up/Down-gap side-by-side white lines indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlGapSideSideWhite(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Up/Down-gap side-by-side white lines indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlGapSideSideWhite(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Up/Down-gap side-by-side white lines indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlGapSideSideWhite(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Gravestone Doji indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlGravestoneDoji(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Gravestone Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlGravestoneDoji(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Gravestone Doji indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlGravestoneDoji(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Gravestone Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlGravestoneDoji(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hammer indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHammer(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Hammer indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHammer(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Hammer indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHammer(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hammer indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHammer(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hanging Man indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHangingMan(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Hanging Man indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHangingMan(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Hanging Man indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHangingMan(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hanging Man indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHangingMan(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Harami Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHarami(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Harami Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHarami(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Harami Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHarami(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Harami Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHarami(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Harami Cross Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHaramiCross(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Harami Cross Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHaramiCross(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Harami Cross Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHaramiCross(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Harami Cross Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHaramiCross(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the High-Wave Candle indicator a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHighWave(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the High-Wave Candle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHighWave(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the High-Wave Candle indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHighWave(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the High-Wave Candle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHighWave(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hikkake Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHikkake(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Hikkake Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHikkake(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Hikkake Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHikkake(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hikkake Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHikkake(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Modified Hikkake Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHikkakeMod(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Modified Hikkake Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHikkakeMod(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Modified Hikkake Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHikkakeMod(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Modified Hikkake Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHikkakeMod(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Homing Pigeon indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlHomingPigeon(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Homing Pigeon indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHomingPigeon(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Homing Pigeon indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHomingPigeon(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Homing Pigeon indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlHomingPigeon(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Identical Three Crows indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlIdentical3Crows(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Identical Three Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlIdentical3Crows(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Identical Three Crows indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlIdentical3Crows(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Identical Three Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlIdentical3Crows(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the In-Neck Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlInNeck(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the In-Neck Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlInNeck(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the In-Neck Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlInNeck(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the In-Neck Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlInNeck(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Inverted Hammer indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlInvertedHammer(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Inverted Hammer indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlInvertedHammer(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Inverted Hammer indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlInvertedHammer(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Inverted Hammer indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlInvertedHammer(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Kicking indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlKicking(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Kicking indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlKicking(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Kicking indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlKicking(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Kicking indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlKicking(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Kicking - bull/bear determined by the longer marubozu indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlKickingByLength(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Kicking - bull/bear determined by the longer marubozu indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlKickingByLength(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Kicking - bull/bear determined by the longer marubozu indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlKickingByLength(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Kicking - bull/bear determined by the longer marubozu indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlKickingByLength(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;
   
    /**
     * Calculates the Ladder Bottom indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #cdlLadderBottom(Instrument instrument, Period period, OfferSide side, int shift)}  
     */
    public int cdlLadderBotton(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Ladder Bottom indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #cdlLadderBottom(Instrument instrument, Period period, OfferSide side, long from, long to)}  
     */
    public int[] cdlLadderBotton(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Ladder Bottom indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #cdlLadderBottom(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}  
     */
    public int[] cdlLadderBotton(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Ladder Bottom indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #cdlLadderBottom(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to)}  
     */
    public int[] cdlLadderBotton(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Ladder Bottom indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlLadderBottom(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Ladder Bottom indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLadderBottom(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Ladder Bottom indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLadderBottom(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Ladder Bottom indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLadderBottom(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Long Legged Doji indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlLongLeggedDoji(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Long Legged Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLongLeggedDoji(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Long Legged Doji indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLongLeggedDoji(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Long Legged Doji indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLongLeggedDoji(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Long Line Candle indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlLongLine(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Long Line Candle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLongLine(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Long Line Candle indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLongLine(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Long Line Candle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlLongLine(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Marubozu indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlMarubozu(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Marubozu indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMarubozu(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Marubozu indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMarubozu(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Marubozu indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMarubozu(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Matching Low indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlMatchingLow(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Matching Low indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMatchingLow(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Matching Low indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMatchingLow(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Matching Low indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMatchingLow(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Mat Hold indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlMathold(Instrument instrument, Period period, OfferSide side, double penetration, int shift) throws JFException;

    /**
     * Calculates the Mat Hold indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMathold(Instrument instrument, Period period, OfferSide side, double penetration, long from, long to) throws JFException;

    /**
     * Calculates the Mat Hold indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMathold(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Mat Hold indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMathold(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Morning Doji Star indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlMorningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, int shift) throws JFException;

    /**
     * Calculates the Morning Doji Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMorningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, long from, long to) throws JFException;

    /**
     * Calculates the Morning Doji Star indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMorningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Morning Doji Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMorningDojiStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Morning Star indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlMorningStar(Instrument instrument, Period period, OfferSide side, double penetration, int shift) throws JFException;

    /**
     * Calculates the Morning Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMorningStar(Instrument instrument, Period period, OfferSide side, double penetration, long from, long to) throws JFException;

    /**
     * Calculates the Morning Star indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMorningStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Morning Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param penetration Percentage of penetration of a candle within another candle
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlMorningStar(Instrument instrument, Period period, OfferSide side, double penetration, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the On-Neck Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlOnNeck(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the On-Neck Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlOnNeck(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the On-Neck Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlOnNeck(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the On-Neck Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlOnNeck(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Piercing Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlPiercing(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Piercing Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.s
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlPiercing(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Piercing Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlPiercing(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Piercing Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlPiercing(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Rickshaw Man indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlRickshawMan(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Rickshaw Man indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlRickshawMan(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Rickshaw Man indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlRickshawMan(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Rickshaw Man indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlRickshawMan(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Rising/Falling Three Methods indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlRiseFall3Methods(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Rising/Falling Three Methods indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlRiseFall3Methods(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Rising/Falling Three Methods indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlRiseFall3Methods(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Rising/Falling Three Methods indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlRiseFall3Methods(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Separating Lines indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlSeparatingLines(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Separating Lines indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlSeparatingLines(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Separating Lines indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlSeparatingLines(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Separating Lines indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlSeparatingLines(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Shooting Star indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlShootingStar(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Shooting Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlShootingStar(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Shooting Star indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlShootingStar(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Shooting Star indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlShootingStar(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Short Line Candle indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlShortLine(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Short Line Candle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlShortLine(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Short Line Candle indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlShortLine(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Short Line Candle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlShortLine(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Spinning Top indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlSpinningTop(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Spinning Top indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlSpinningTop(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Spinning Top indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlSpinningTop(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Spinning Top indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlSpinningTop(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Stalled Pattern indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlStalledPattern(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Stalled Pattern indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlStalledPattern(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Stalled Pattern indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlStalledPattern(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Stalled Pattern indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlStalledPattern(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Stick Sandwich indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlStickSandwich(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Stick Sandwich indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlStickSandwich(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;
    
    /**
     * Calculates the Stick Sandwich indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlStickSandwich(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Stick Sandwich indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlStickSandwich(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Takuri indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlTakuri(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Takuri indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTakuri(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Takuri indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTakuri(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Takuri indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTakuri(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Tasuki Gap indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlTasukiGap(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Tasuki Gap indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTasukiGap(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Tasuki Gap indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTasukiGap(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Tasuki Gap indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTasukiGap(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Thrusting Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlThrusting(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Thrusting Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlThrusting(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Thrusting Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlThrusting(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Thrusting Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlThrusting(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Tristar Pattern for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlTristar(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Tristar Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTristar(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Tristar Pattern for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTristar(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Tristar Pattern for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlTristar(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Unique 3 River indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlUnique3River(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Unique 3 River indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlUnique3River(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Unique 3 River indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlUnique3River(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Unique 3 River indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlUnique3River(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Upside Gap Two Crows indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlUpsideGap2Crows(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Upside Gap Two Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlUpsideGap2Crows(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Upside Gap Two Crows indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlUpsideGap2Crows(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Upside Gap Two Crows indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlUpsideGap2Crows(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Upside/Downside Gap Three Methods for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int cdlXsideGap3Methods(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Upside/Downside Gap Three Methods for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlXsideGap3Methods(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Upside/Downside Gap Three Methods for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlXsideGap3Methods(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Upside/Downside Gap Three Methods for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] cdlXsideGap3Methods(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Ceil indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ceil(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Ceil indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ceil(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Ceil indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ceil(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * 
     * Calculates the Vector Ceil indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ceil(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Chande Momentum Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double cmo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Chande Momentum Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cmo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Chande Momentum Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cmo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Chande Momentum Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cmo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Center Of Gravity indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param smoothPeriod smoothing period 
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'CG Line', 'Signal Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cog(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int smoothPeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Center Of Gravity indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param smoothPeriod smoothing period 
     * @param maType {@link IIndicators.MaType type} of moving average
     ** @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'CG Line', 'Signal Line' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] cog(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int smoothPeriod, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the Center Of Gravity indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param smoothPeriod smoothing period 
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'CG Line', 'Signal Line' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] cog(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int smoothPeriod, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Center Of Gravity indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param smoothPeriod smoothing period 
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'CG Line', 'Signal Line' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] cog(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int smoothPeriod, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Pearson's Correlation Coefficient for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double correl(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Pearson's Correlation Coefficient for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] correl(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Pearson's Correlation Coefficient for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] correl(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Pearson's Correlation Coefficient for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] correl(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Cos for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double cos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric Cos for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Cos for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric Cos for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cos(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Cosh for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double cosh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric Cosh for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cosh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Cosh for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cosh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric Cosh for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] cosh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to)throws JFException;

    /**
     * Calculates the Double Exponential Moving Average for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double dema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Double Exponential Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] dema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Double Exponential Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] dema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Double Exponential Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] dema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Div for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double div(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int shift) throws JFException;

    /**
     * Calculates the Vector Arithmetic Div for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] div(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Div for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] div(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Arithmetic Div for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] div(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2,
            AppliedPrice appliedPrice2, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Average Directional Movement Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'ADX', '+DI', '-DI'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] dmi(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Average Directional Movement Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'ADX', '+DI', '-DI' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] dmi(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Average Directional Movement Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'ADX', '+DI', '-DI' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] dmi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Average Directional Movement Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'ADX', '+DI', '-DI' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] dmi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Donchian Channel indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'High', 'Low'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] donchian(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;    

    /**
     * Calculates the Donchian Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'High', 'Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] donchian(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Donchian Channel indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'High', 'Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] donchian(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Donchian Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'High', 'Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] donchian(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Directional Movement Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double dx(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Directional Movement Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] dx(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Directional Movement Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] dx(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Directional Movement Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] dx(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Exponential Moving Average for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Exponential_Moving_Average>Exponential Moving Average</a>
     */
    public double ema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;
    
    /**
     * Calculates the Exponential Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code>parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar or tick
     * @param period period of the bar or TICK
     * @param side Bid or Ask side of the bar which price to take for 1sec bars generation for ticks or side for bars
     * @param appliedPrice type of input data
     * @param timePeriod time period value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Exponential_Moving_Average>Exponential Moving Average</a>
     */
    public double[] ema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Exponential Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Exponential_Moving_Average>Exponential Moving Average</a>
     */
    public double[] ema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Exponential Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Exponential_Moving_Average>Exponential Moving Average</a>
     */
    public double[] ema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the EMA Envelope indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Low Band', 'High Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] emaEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double deviation, int shift) throws JFException;

    /**
     * Calculates the EMA Envelope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] emaEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double deviation, long from, long to) throws JFException;

    /**
     * Calculates the EMA Envelope indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] emaEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double deviation, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the EMA Envelope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] emaEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double deviation, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Exp indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double exp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Arithmetic Exp indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] exp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Exp indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] exp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Arithmetic Exp indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] exp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift)}
     */
    public double[] fibPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to)}
     */
    public double[][] fibPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] fibPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to)}
     */
    public double[][] fibPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot2(Instrument instrument, Period period, OfferSide side, int shift)}
     */
    public double[] fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot2(Instrument instrument, Period period, OfferSide side, long from, long to)}
     */
    public double[][] fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #fibPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to)}
     */
    public double[][] fibPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] fibPivot2(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fibPivot2(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Fibonacci Pivot Points for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fibPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Fibonacci Pivot Points for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)', 
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'  
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fibPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Vector Floor indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double floor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Floor indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] floor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Floor indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] floor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Floor indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] floor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Force Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double force(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Force Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] force(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, long from, long to) throws JFException;
    
    /**
     * Calculates the Force Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] force(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType,Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Force Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] force(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, Filter filter, long from, long to) throws JFException;
        
    /**
     * Calculates the Fractal indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Maximums', 'Minimums' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] fractal(Instrument instrument, Period period, OfferSide side, int barsOnSides, int shift) throws JFException;

    /**
     * Calculates the Fractal indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Maximums', 'Minimums' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fractal(Instrument instrument, Period period, OfferSide side, int barsOnSides, long from, long to) throws JFException;

    /**
     * Calculates the Fractal indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Maximums', 'Minimums' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fractal(Instrument instrument, Period period, OfferSide side, int barsOnSides, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Fractal indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Maximums', 'Minimums' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fractal(Instrument instrument, Period period, OfferSide side, int barsOnSides, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Fractal lines indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'High', 'Low'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] fractalLines(Instrument instrument, Period period, OfferSide side, int barsOnSides, int shift) throws JFException;

    /**
     * Calculates the Fractal lines indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'High', 'Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fractalLines(Instrument instrument, Period period, OfferSide side, int barsOnSides, long from, long to) throws JFException;

    /**
     * Calculates the Fractal lines indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'High', 'Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fractalLines(Instrument instrument, Period period, OfferSide side, int barsOnSides, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Fractal lines indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param barsOnSides number of bars on the sides
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'High', 'Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] fractalLines(Instrument instrument, Period period, OfferSide side, int barsOnSides, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Gator Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] gator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, int shift) throws JFException;        

    /**
     * Calculates the Gator Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] gator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Gator Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] gator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Gator Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param jawTimePeriod jaw time period
     * @param teethTimePeriod teeth time period
     * @param lipsTimePeriod lips time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] gator(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Guppy Multiple Moving Average for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortEMA1Period short EMA1 period
     * @param shortEMA2Period short EMA2 period
     * @param shortEMA3Period short EMA3 period
     * @param shortEMA4Period short EMA4 period
     * @param shortEMA5Period short EMA5 period
     * @param shortEMA6Period short EMA6 period
     * @param longEMA1Period long EMA1 period
     * @param longEMA2Period long EMA2 period
     * @param longEMA3Period long EMA3 period
     * @param longEMA4Period long EMA4 period
     * @param longEMA5Period long EMA5 period
     * @param longEMA6Period long EMA6 period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order:
     * 'Short EMA1', 'Short EMA2', 'Short EMA3', 'Short EMA4', 'Short EMA5', 'Short EMA6',
     * 'Long EMA1', 'Long EMA2', 'Long EMA3', 'Long EMA4', 'Long EMA5', 'Long EMA6'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] gmma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice,
            int shortEMA1Period, int shortEMA2Period, int shortEMA3Period, int shortEMA4Period, int shortEMA5Period, int shortEMA6Period,
            int longEMA1Period, int longEMA2Period, int longEMA3Period, int longEMA4Period, int longEMA5Period, int longEMA6Period,
            int shift) throws JFException;

    /**
     * Calculates the Guppy Multiple Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortEMA1Period short EMA1 period
     * @param shortEMA2Period short EMA2 period
     * @param shortEMA3Period short EMA3 period
     * @param shortEMA4Period short EMA4 period
     * @param shortEMA5Period short EMA5 period
     * @param shortEMA6Period short EMA6 period
     * @param longEMA1Period long EMA1 period
     * @param longEMA2Period long EMA2 period
     * @param longEMA3Period long EMA3 period
     * @param longEMA4Period long EMA4 period
     * @param longEMA5Period long EMA5 period
     * @param longEMA6Period long EMA6 period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order:
     * 'Short EMA1', 'Short EMA2', 'Short EMA3', 'Short EMA4', 'Short EMA5', 'Short EMA6',
     * 'Long EMA1', 'Long EMA2', 'Long EMA3', 'Long EMA4', 'Long EMA5', 'Long EMA6'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] gmma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice,
            int shortEMA1Period, int shortEMA2Period, int shortEMA3Period, int shortEMA4Period, int shortEMA5Period, int shortEMA6Period,
            int longEMA1Period, int longEMA2Period, int longEMA3Period, int longEMA4Period, int longEMA5Period, int longEMA6Period,
            long from, long to) throws JFException;

    /**
     * Calculates the Guppy Multiple Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortEMA1Period short EMA1 period
     * @param shortEMA2Period short EMA2 period
     * @param shortEMA3Period short EMA3 period
     * @param shortEMA4Period short EMA4 period
     * @param shortEMA5Period short EMA5 period
     * @param shortEMA6Period short EMA6 period
     * @param longEMA1Period long EMA1 period
     * @param longEMA2Period long EMA2 period
     * @param longEMA3Period long EMA3 period
     * @param longEMA4Period long EMA4 period
     * @param longEMA5Period long EMA5 period
     * @param longEMA6Period long EMA6 period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order:
     * 'Short EMA1', 'Short EMA2', 'Short EMA3', 'Short EMA4', 'Short EMA5', 'Short EMA6',
     * 'Long EMA1', 'Long EMA2', 'Long EMA3', 'Long EMA4', 'Long EMA5', 'Long EMA6'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] gmma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice,
            int shortEMA1Period, int shortEMA2Period, int shortEMA3Period, int shortEMA4Period, int shortEMA5Period, int shortEMA6Period,
            int longEMA1Period, int longEMA2Period, int longEMA3Period, int longEMA4Period, int longEMA5Period, int longEMA6Period,
            Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Guppy Multiple Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortEMA1Period short EMA1 period
     * @param shortEMA2Period short EMA2 period
     * @param shortEMA3Period short EMA3 period
     * @param shortEMA4Period short EMA4 period
     * @param shortEMA5Period short EMA5 period
     * @param shortEMA6Period short EMA6 period
     * @param longEMA1Period long EMA1 period
     * @param longEMA2Period long EMA2 period
     * @param longEMA3Period long EMA3 period
     * @param longEMA4Period long EMA4 period
     * @param longEMA5Period long EMA5 period
     * @param longEMA6Period long EMA6 period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order:
     * 'Short EMA1', 'Short EMA2', 'Short EMA3', 'Short EMA4', 'Short EMA5', 'Short EMA6',
     * 'Long EMA1', 'Long EMA2', 'Long EMA3', 'Long EMA4', 'Long EMA5', 'Long EMA6'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] gmma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice,
            int shortEMA1Period, int shortEMA2Period, int shortEMA3Period, int shortEMA4Period, int shortEMA5Period, int shortEMA6Period,
            int longEMA1Period, int longEMA2Period, int longEMA3Period, int longEMA4Period, int longEMA5Period, int longEMA6Period,
            Filter filter, long from, long to) throws JFException;

    /**	
     * Calculates the Heikin Ashi indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array with prices. The values are placed in the following order: OPEN, CLOSE, HIGH, LOW
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #heikinAshi(Instrument instrument, Period period, OfferSide side, int shift)}
     */
    public double[] heikenAshi(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return array of arrays with prices. The values are placed in the following order: OPEN, CLOSE, HIGH, LOW
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #heikinAshi(Instrument instrument, Period period, OfferSide side, long from, long to)}
     */
    public double[][] heikenAshi(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return array of arrays with prices. The values are placed in the following order: OPEN, CLOSE, HIGH, LOW
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #heikinAshi(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] heikenAshi(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return array with prices. The values are placed in the following order: OPEN, CLOSE, HIGH, LOW
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>     
     */
    public double[] heikinAshi(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.      
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return array of arrays with prices. The values are placed in the following order: OPEN, CLOSE, HIGH, LOW
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] heikinAshi(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter     
     * @return array of arrays with prices. The values are placed in the following order: OPEN, CLOSE, HIGH, LOW
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] heikinAshi(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return array of arrays with prices. The values are placed in the following order: OPEN, CLOSE, HIGH, LOW
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] heikinAshi(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return Heikin Ashi candle 'shift' candles back
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>     
     */
    public IBar heikinAshiSingle(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.      
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded     
     * @return array of Heikin Ashi candles
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public IBar[] heikinAshiSingle(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;
   
    /**
     * Calculates the Heikin Ashi indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter     
     * @return array of Heikin Ashi candles
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public IBar[] heikinAshiSingle(
    		Instrument instrument,
    		Period period,
    		OfferSide side,
    		Filter filter,
    		int numberOfCandlesBefore,
    		long time,
    		int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Heikin Ashi indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return array of Heikin Ashi candles
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public IBar[] heikinAshiSingle(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * The Heikin Ashi Smoothed first calculation step.
     * <p>Consider multiple usage examples:
     *
     * <pre>{@code
     * double[] heikenAshiByShift = indicators.heikenAshi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA, 30, MaType.SMA).calculate(shift);
     * double[][] heikenAshiByTimeInterval = indicators.heikenAshi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA, 30, MaType.SMA).calculate(from, to);
     * double[][] heikenAshiByCandleInterval = indicators.heikenAshi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA, 30, MaType.SMA).calculate(10, time, 0);
     * }</pre>
     *
     * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
     * @param appliedPrice type of input data
     * @param side Bid or Ask side for tick feeds
     * @param timePeriod heikin time period value
     * @param maType heikin moving average type
     * @param smoothingTimePeriod smoothing MA time period value
     * @param smoothingMAType smoothing moving average type
     * @return {@link IIndicatorCalculator} object to be used for the second calculation step
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
     * @deprecated replaced by {@link #heikinAshiSmooth(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod, MaType maType, int secondaryTimePeriod, MaType secondaryMAType)}
     */
    public IIndicatorCalculator<double[], double[][]> heikinAshiSmooth(
            IFeedDescriptor feedDescriptor,
            AppliedPrice appliedPrice,
            OfferSide side,
            int timePeriod,
            MaType maType,
            int smoothingTimePeriod,
            MaType smoothingMAType);

    /**
     * Calculates the Heikin Ashi Smoothed indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod heikin time period value
     * @param maType heikin moving average type
     * @param smoothingTimePeriod smoothing MA time period value
     * @param smoothingMAType smoothing moving average type
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'HA open', 'HA close', 'HA high', 'HA low'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] heikinAshiSmooth(
            Instrument instrument,
            Period period,
            OfferSide side,
            int timePeriod,
            MaType maType,
            int smoothingTimePeriod,
            MaType smoothingMAType,
            int shift) throws JFException;

    /**
     * Calculates the Heikin Ashi Smoothed indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod heikin time period value
     * @param maType heikin moving average type
     * @param smoothingTimePeriod smoothing MA time period value
     * @param smoothingMAType smoothing moving average type
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'HA open', 'HA close', 'HA high', 'HA low'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] heikinAshiSmooth(
            Instrument instrument,
            Period period,
            OfferSide side,
            int timePeriod,
            MaType maType,
            int smoothingTimePeriod,
            MaType smoothingMAType,
            long from,
            long to) throws JFException;

    /**
     * Calculates the Heikin Ashi Smoothed indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod heikin time period value
     * @param maType heikin moving average type
     * @param smoothingTimePeriod smoothing MA time period value
     * @param smoothingMAType smoothing moving average type
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'HA open', 'HA close', 'HA high', 'HA low'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] heikinAshiSmooth(
            Instrument instrument,
            Period period,
            OfferSide side,
            int timePeriod,
            MaType maType,
            int smoothingTimePeriod,
            MaType smoothingMAType,
            Filter filter,
            int numberOfCandlesBefore,
            long time,
            int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Heikin Ashi Smoothed indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod heikin time period value
     * @param maType heikin moving average type
     * @param smoothingTimePeriod smoothing MA time period value
     * @param smoothingMAType smoothing moving average type
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'HA open', 'HA close', 'HA high', 'HA low'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
      public double[][] heikinAshiSmooth(
              Instrument instrument,
              Period period,
              OfferSide side,
              int timePeriod,
              MaType maType,
              int smoothingTimePeriod,
              MaType smoothingMAType,
              Filter filter,
              long from,
              long to) throws JFException;

    /**
     * Calculates the Hull Moving Average indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double hma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;
    
    /**
     * Calculates the Hull Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] hma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Hull Moving Average indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] hma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hull Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] hma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Dominant Cycle Period indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ht_dcperiod(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Hilbert Transform - Dominant Cycle Period indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_dcperiod(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Dominant Cycle Period indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_dcperiod(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hilbert Transform - Dominant Cycle Period indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_dcperiod(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Dominant Cycle Phase for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ht_dcphase(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Hilbert Transform - Dominant Cycle Phase for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_dcphase(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Dominant Cycle Phase for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_dcphase(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hilbert Transform - Dominant Cycle Phase for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_dcphase(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Phasor Components indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar, outputs are returned in the following order: 'Phase', 'Quadrature'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_phasor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Hilbert Transform - Phasor Components indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Phase', 'Quadrature' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ht_phasor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Phasor Components indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Phase', 'Quadrature' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ht_phasor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hilbert Transform - Phasor Components indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Phase', 'Quadrature' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ht_phasor(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - SineWave indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Sine', 'Lead Sine'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ht_sine(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Hilbert Transform - SineWave indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Sine', 'Lead Sine' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ht_sine(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - SineWave indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Sine', 'Lead Sine' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ht_sine(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hilbert Transform - SineWave indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Sine', 'Lead Sine' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ht_sine(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Instantaneous Trendline indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Hilbert_Transform_-_Instantaneous_Trendline>Hilbert Transform - Instantaneous Trendline indicator</a>
     */
    public double ht_trendline(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Hilbert Transform - Instantaneous Trendline indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Hilbert_Transform_-_Instantaneous_Trendline>Hilbert Transform - Instantaneous Trendline indicator</a>
     */
    public double[] ht_trendline(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Instantaneous Trendline indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Hilbert_Transform_-_Instantaneous_Trendline>Hilbert Transform - Instantaneous Trendline indicator</a>
     */
    public double[] ht_trendline(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hilbert Transform - Instantaneous Trendline indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Hilbert_Transform_-_Instantaneous_Trendline>Hilbert Transform - Instantaneous Trendline indicator</a>
     */
    public double[] ht_trendline(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Trend vs Cycle Mode indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int ht_trendmode(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Hilbert Transform - Trend vs Cycle Mode indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] ht_trendmode(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Hilbert Transform - Trend vs Cycle Mode indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] ht_trendmode(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Hilbert Transform - Trend vs Cycle Mode indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] ht_trendmode(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Ichimoku indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param tenkan tenkan
     * @param kijun kijun
     * @param senkou senkou
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Tenkan Sen', 'Ki-jun Sen', 'Chinkou Span', 
     * 'Senkou A', 'Senkou B', 'Cloud(Senkou A)', 'Cloud(Senkou B)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ichimoku(Instrument instrument, Period period, OfferSide side, int tenkan, int kijun, int senkou, int shift) throws JFException;

    /**
     * Calculates the Ichimoku indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param tenkan tenkan
     * @param kijun kijun
     * @param senkou senkou
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Tenkan Sen', 'Ki-jun Sen', 'Chinkou Span', 
     * 'Senkou A', 'Senkou B', 'Cloud(Senkou A)', 'Cloud(Senkou B)'  
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ichimoku(Instrument instrument, Period period, OfferSide side, int tenkan, int kijun, int senkou, long from, long to) throws JFException;

    /**
     * Calculates the Ichimoku indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param tenkan tenkan
     * @param kijun kijun
     * @param senkou senkou
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Tenkan Sen', 'Ki-jun Sen', 'Chinkou Span', 
     * 'Senkou A', 'Senkou B', 'Cloud(Senkou A)', 'Cloud(Senkou B)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ichimoku(Instrument instrument, Period period, OfferSide side, int tenkan, int kijun, int senkou, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Ichimoku indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param tenkan tenkan
     * @param kijun kijun
     * @param senkou senkou
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Tenkan Sen', 'Ki-jun Sen', 'Chinkou Span', 
     * 'Senkou A', 'Senkou B', 'Cloud(Senkou A)', 'Cloud(Senkou B)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] ichimoku(Instrument instrument, Period period, OfferSide side, int tenkan, int kijun, int senkou, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Kairi indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double kairi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Kairi indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] kairi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the Kairi indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] kairi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Kairi indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] kairi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, Filter filter, long from, long to) throws JFException;
     
    /**
     * Calculates the Kaufman Adaptive Moving Average for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, int shift)}      
     */
    public double kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Kaufman Adaptive Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, long from, long to)}      
     */
    public double[] kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Kaufman Adaptive Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}      
     */
    public double[] kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Kaufman Adaptive Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, Filter filter, long from, long to)}      
     */
    public double[] kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Kaufman Adaptive Moving Average for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period 
     * @param fastMAPeriod fast moving average period
     * @param slowMAPeriod slow moving average period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, int shift) throws JFException;

    /**
     * Calculates the Kaufman Adaptive Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param fastMAPeriod fast moving average period
     * @param slowMAPeriod slow moving average period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, long from, long to) throws JFException;

    /**
     * Calculates the Kaufman Adaptive Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param fastMAPeriod fast moving average period
     * @param slowMAPeriod slow moving average period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Kaufman Adaptive Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param fastMAPeriod fast moving average period
     * @param slowMAPeriod slow moving average period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] kama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastMAPeriod, int slowMAPeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Keltner Bands (Based on ATR) indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param emaPeriod EMA time period
     * @param atrPeriod ATR time period
     * @param multiplier ATR multiplier
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Upper Band', 'Middle EMA', 'Lower Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] kbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int emaPeriod, int atrPeriod, double multiplier, int shift) throws JFException;

    /**
     * Calculates the Keltner Bands (Based on ATR) indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param emaPeriod EMA time period
     * @param atrPeriod ATR time period
     * @param multiplier ATR multiplier
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bar, outputs are returned in the following order: 'Upper Band', 'Middle EMA', 'Lower Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] kbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int emaPeriod, int atrPeriod, double multiplier, long from, long to) throws JFException;

    /**
     * Calculates the Keltner Bands (Based on ATR) indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param emaPeriod EMA time period
     * @param atrPeriod ATR time period
     * @param multiplier ATR multiplier
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bar, outputs are returned in the following order: 'Upper Band', 'Middle EMA', 'Lower Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] kbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int emaPeriod, int atrPeriod, double multiplier, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Keltner Bands (Based on ATR) indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param emaPeriod EMA time period
     * @param atrPeriod ATR time period
     * @param multiplier ATR multiplier
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bar, outputs are returned in the following order: 'Upper Band', 'Middle EMA', 'Lower Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] kbands(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int emaPeriod, int atrPeriod, double multiplier, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the KDJ indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriodK time period for building the %K line
     * @param timePeriodD time period for building the %D line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowKPeriod smoothing for making the %K line.
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowDPeriod smoothing for making the %D line
     * @param slowJMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowJPeriod smoothing for making the %j line
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: '%K', '%D', '%J'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     * @deprecated replaced by {@link #kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, int shift)}
     */
    public double[] kdj(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriodK, int timePeriodD, MaType slowKMaType, int slowKPeriod, MaType slowDMaType, int slowDPeriod,MaType slowJMaType, int slowJPeriod, int shift) throws JFException;

    /**
     * Calculates the KDJ indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriodK time period for building the %K line
     * @param timePeriodD time period for building the %D line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowKPeriod smoothing for making the %K line.
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowDPeriod smoothing for making the %D line
     * @param slowJMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowJPeriod smoothing for making the %j line
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '%K', '%D', '%J' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, long from, long to)}
     */
    public double[][] kdj(Instrument instrument, Period period, OfferSide side,AppliedPrice appliedPrice, int timePeriodK, int timePeriodD, MaType slowKMaType, int slowKPeriod, MaType slowDMaType, int slowDPeriod,MaType slowJMaType, int slowJPeriod, long from, long to) throws JFException;

    /**
     * Calculates the KDJ indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriodK time period for building the %K line
     * @param timePeriodD time period for building the %D line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowKPeriod smoothing for making the %K line.
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowDPeriod smoothing for making the %D line
     * @param slowJMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowJPeriod smoothing for making the %j line
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: '%K', '%D', '%J' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] kdj(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriodK, int timePeriodD, MaType slowKMaType, int slowKPeriod, MaType slowDMaType, int slowDPeriod,MaType slowJMaType, int slowJPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the KDJ indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriodK time period for building the %K line
     * @param timePeriodD time period for building the %D line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowKPeriod smoothing for making the %K line.
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowDPeriod smoothing for making the %D line
     * @param slowJMaType {@link IIndicators.MaType type} of moving average for %D
     * @param slowJPeriod smoothing for making the %j line
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '%K', '%D', '%J' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, Filter filter, long from, long to)}
     */
    public double[][] kdj(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriodK, int timePeriodD, MaType slowKMaType, int slowKPeriod, MaType slowDMaType, int slowDPeriod,MaType slowJMaType, int slowJPeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the KDJ indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod period for %K value
     * @param slowKPeriod smoothing for making the %K line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowDPeriod smoothing for making the %D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param kMultiplier multiplier for %K value
     * @param dMultiplier multiplier for %D value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: '%K', '%D', '%J'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[] kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, int shift) throws JFException;

    /**
     * Calculates the KDJ indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod period for %K value
     * @param slowKPeriod smoothing for making the %K line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowDPeriod smoothing for making the %D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param kMultiplier multiplier for %K value
     * @param dMultiplier multiplier for %D value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '%K', '%D', '%J'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, long from, long to) throws JFException;

    /**
     * Calculates the KDJ indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod period for %K value
     * @param slowKPeriod smoothing for making the %K line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowDPeriod smoothing for making the %D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param kMultiplier multiplier for %K value
     * @param dMultiplier multiplier for %D value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: '%K', '%D', '%J'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the KDJ indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod period for %K value
     * @param slowKPeriod smoothing for making the %K line
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for %K
     * @param slowDPeriod smoothing for making the %D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for %D
     * @param kMultiplier multiplier for %K value
     * @param dMultiplier multiplier for %D value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '%K', '%D', '%J'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] kdj(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Keltner Channel indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period 
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Keltner Channel Up', 'Keltner Channel Middle', 'Keltner Channel Low'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */    
    public double[] keltner(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Keltner Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Keltner Channel Up', 'Keltner Channel Middle', 'Keltner Channel Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] keltner(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Keltner Channel indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Keltner Channel Up', 'Keltner Channel Middle', 'Keltner Channel Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] keltner(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Keltner Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Keltner Channel Up', 'Keltner Channel Middle', 'Keltner Channel Low' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] keltner(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Laguerre-ACS1 indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param ma ma
     * @param gamma gamma
     * @param lookback lookback
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #lagACS1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, int shift)} 
     */
    public double lasacs1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, int shift) throws JFException;

    /**
     * Calculates the Laguerre-ACS1 indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param ma ma
     * @param gamma gamma
     * @param lookback lookback
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #lagACS1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, long from, long to)} 
     */
    public double[] lasacs1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, long from, long to) throws JFException;

    /**
     * Calculates the Laguerre-ACS1 indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param ma ma
     * @param gamma gamma
     * @param lookback lookback
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #lagACS1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)} 
     */
    public double[] lasacs1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Laguerre-ACS1 indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param ma ma
     * @param gamma gamma
     * @param lookback lookback  
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double lagACS1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, int shift) throws JFException;
    
    /**
     * Calculates the Laguerre-ACS1 indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param ma ma
     * @param gamma gamma
     * @param lookback lookback
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lagACS1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, long from, long to) throws JFException;

    /**
     * Calculates the Laguerre-ACS1 indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param ma ma
     * @param gamma gamma
     * @param lookback lookback
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lagACS1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Laguerre-ACS1 indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param ma ma
     * @param gamma gamma
     * @param lookback lookback
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lagACS1(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int ma, double gamma, int lookback, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Linear Regression indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double linearReg(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Linear Regression indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearReg(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Linear Regression indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearReg(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Linear Regression indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearReg(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Linear Regression Angle indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period 
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double linearRegAngle(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Linear Regression Angle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegAngle(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Linear Regression Angle indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegAngle(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Linear Regression Angle indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegAngle(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Linear Regression Intercept indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period 
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double linearRegIntercept(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Linear Regression Intercept indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegIntercept(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Linear Regression Intercept indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegIntercept(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Linear Regression Intercept indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegIntercept(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Linear Regression Slope indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period 
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double linearRegSlope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Linear Regression Slope indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegSlope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Linear Regression Slope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegSlope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;
    
    /**
     * Calculates the Linear Regression Slope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] linearRegSlope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Log Natural for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ln(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Log Natural for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ln(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Vector Log Natural for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ln(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;
    
    /**
     * Calculates the Vector Log Natural for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ln(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Log10 for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double log10(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Log10 for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] log10(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Vector Log10 for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] log10(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;
    
    /**
     * Calculates the Vector Log10 for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] log10(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Ehlers Laguerre Relative Strength Index indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param dampingFactor Damping Factor
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double lrsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double dampingFactor, int shift) throws JFException;

    /**
     * Calculates the Ehlers Laguerre Relative Strength Index indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param dampingFactor Damping Factor
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lrsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double dampingFactor, long from, long to) throws JFException;

    /**
     * Calculates the Ehlers Laguerre Relative Strength Index indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param dampingFactor Damping Factor
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lrsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double dampingFactor, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Ehlers Laguerre Relative Strength Index indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param dampingFactor Damping Factor
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lrsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double dampingFactor, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Linear Weighted Moving Average indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period 
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double lwma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Linear Weighted Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lwma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Linear Weighted Moving Average indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lwma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Linear Weighted Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] lwma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Moving Average for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, long from, long to) throws JFException;
    
    /**
     * Calculates the Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Moving Average Convergence/Divergence indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param slowPeriod period for the slow MA
     * @param signalPeriod smoothing for the signal line
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] macd(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, int signalPeriod, int shift) throws JFException;

    /**
     * Calculates the Moving Average Convergence/Divergence indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param slowPeriod period for the slow MA
     * @param signalPeriod smoothing for the signal line
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macd(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, int signalPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Moving Average Convergence/Divergence indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param slowPeriod period for the slow MA
     * @param signalPeriod smoothing for the signal line
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macd(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, int signalPeriod, long from, long to) throws JFException;
    
    /**
     * Calculates the Moving Average Convergence/Divergence indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param slowPeriod period for the slow MA
     * @param signalPeriod smoothing for the signal line
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macd(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, int signalPeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the MACD with controllable MA type indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param fastMaType {@link IIndicators.MaType type} of fast moving average
     * @param slowPeriod period for the slow MA
     * @param slowMaType {@link IIndicators.MaType type} of slow moving average
     * @param signalPeriod smoothing for the signal line
     * @param signalMaType {@link IIndicators.MaType type} of signal moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] macdExt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, MaType fastMaType, int slowPeriod, MaType slowMaType, int signalPeriod, MaType signalMaType, int shift) throws JFException;

    /**
     * Calculates the MACD with controllable MA type indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param fastMaType {@link IIndicators.MaType type} of fast moving average
     * @param slowPeriod period for the slow MA
     * @param slowMaType {@link IIndicators.MaType type} of slow moving average
     * @param signalPeriod smoothing for the signal line
     * @param signalMaType {@link IIndicators.MaType type} of signal moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macdExt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, MaType fastMaType, int slowPeriod, MaType slowMaType, int signalPeriod, MaType signalMaType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the MACD with controllable MA type indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param fastMaType {@link IIndicators.MaType type} of fast moving average
     * @param slowPeriod period for the slow MA
     * @param slowMaType {@link IIndicators.MaType type} of slow moving average
     * @param signalPeriod smoothing for the signal line
     * @param signalMaType {@link IIndicators.MaType type} of signal moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macdExt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, MaType fastMaType, int slowPeriod, MaType slowMaType, int signalPeriod, MaType signalMaType, long from, long to) throws JFException;
    
    /**
     * Calculates the MACD with controllable MA type indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for the fast MA
     * @param fastMaType {@link IIndicators.MaType type} of fast moving average
     * @param slowPeriod period for the slow MA
     * @param slowMaType {@link IIndicators.MaType type} of slow moving average
     * @param signalPeriod smoothing for the signal line
     * @param signalMaType {@link IIndicators.MaType type} of signal moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macdExt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, MaType fastMaType, int slowPeriod, MaType slowMaType, int signalPeriod, MaType signalMaType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Moving Average Convergence/Divergence Fix indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param signalPeriod smoothing for the signal line
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] macdFix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int signalPeriod, int shift) throws JFException;

    /**
     * Calculates the Moving Average Convergence/Divergence Fix indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param signalPeriod smoothing for the signal line
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macdFix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int signalPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Moving Average Convergence/Divergence Fix indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param signalPeriod smoothing for the signal line
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macdFix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int signalPeriod, long from, long to) throws JFException;
    
    /**
     * Calculates the Moving Average Convergence/Divergence Fix indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param signalPeriod smoothing for the signal line
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MACD', 'MACD Signal', 'MACD Hist' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] macdFix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int signalPeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the MA Envelope indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Low Band', 'High Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] maEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double deviation, int shift) throws JFException;

    /**
     * Calculates the MA Envelope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] maEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice,int timePeriod, double deviation, long from, long to) throws JFException;

    /**
     * Calculates the MA Envelope indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] maEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double deviation, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the MA Envelope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param deviation deviation
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] maEnvelope(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double deviation, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the MESA Adaptive Moving Average indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastLimit upper limit use in the adaptive algorithm
     * @param slowLimit lower limit use in the adaptive algorithm
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'MAMA', 'FAMA'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double fastLimit, double slowLimit, int shift) throws JFException;

    /**
     * Calculates the MESA Adaptive Moving Average indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastLimit upper limit use in the adaptive algorithm
     * @param slowLimit lower limit use in the adaptive algorithm
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'MAMA', 'FAMA' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] mama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double fastLimit, double slowLimit, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the MESA Adaptive Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastLimit upper limit use in the adaptive algorithm
     * @param slowLimit lower limit use in the adaptive algorithm
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MAMA', 'FAMA' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] mama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double fastLimit, double slowLimit, long from, long to) throws JFException;
    
    /**
     * Calculates the MESA Adaptive Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastLimit upper limit use in the adaptive algorithm
     * @param slowLimit lower limit use in the adaptive algorithm
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'MAMA', 'FAMA' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] mama(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, double fastLimit, double slowLimit, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the World Stock Market Time indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return market values for the specified bar as follows:
     * each element of an array is an array of type Object itself or null
     * where the first element of the latter array represents a market (type <code>WSMTimeIndicator.Market</code>)
     * and the second element is a string which describes the market event: <code>open</code> or <code>close</code>
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    
    public Object[] wsmTime(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the World Stock Market Time indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return market values for the specified bars as follows:
     * each element of an array is an array of type Object itself or null
     * where the first element of the latter array represents a market (type <code>WSMTimeIndicator.Market</code>)
     * and the second element is a string which describes the market event: <code>open</code> or <code>close</code> 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public Object[] wsmTime(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the World Stock Market Time indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return market values for the specified bars as follows:
     * each element of an array is an array of type Object itself or null
     * where the first element of the latter array represents a market (type <code>WSMTimeIndicator.Market</code>)
     * and the second element is a string which describes the market event: <code>open</code> or <code>close</code> 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public Object[] wsmTime(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;
    
    /**
     * Calculates the World Stock Market Time indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return market values for the specified bars as follows:
     * each element of an array is an array of type Object itself or null
     * where the first element of the latter array represents a market (type <code>WSMTimeIndicator.Market</code>)
     * and the second element is a string which describes the market event: <code>open</code> or <code>close</code> 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public Object[] wsmTime(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Moving average with variable period indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param minPeriod value less than minimum will be changed to Minimum period
     * @param maxPeriod value higher than maximum will be changed to Maximum period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double mavp(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int minPeriod, int maxPeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Moving average with variable period indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param minPeriod value less than minimum will be changed to Minimum period
     * @param maxPeriod value higher than maximum will be changed to Maximum period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mavp(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int minPeriod, int maxPeriod, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Moving average with variable period indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param minPeriod value less than minimum will be changed to Minimum period
     * @param maxPeriod value higher than maximum will be changed to Maximum period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mavp(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int minPeriod, int maxPeriod, MaType maType, long from, long to) throws JFException;
    
    /**
     * Calculates the Moving average with variable period indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param minPeriod value less than minimum will be changed to Minimum period
     * @param maxPeriod value higher than maximum will be changed to Maximum period
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mavp(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int minPeriod, int maxPeriod, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Highest value over a specified period for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double max(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Highest value over a specified period for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] max(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Highest value over a specified period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] max(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;
    
    /**
     * Calculates the Highest value over a specified period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] max(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the McClellan Histogram for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param signalMAPeriods Signal MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double mcclHist(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, int signalMAPeriods, MaType maType, int shift) throws JFException;

    /**
     * Calculates the McClellan Histogram for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param signalMAPeriods Signal MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclHist(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, int signalMAPeriods, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the McClellan Histogram for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param signalMAPeriods Signal MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclHist(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, int signalMAPeriods, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the McClellan Histogram for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param signalMAPeriods Signal MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclHist(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, int signalMAPeriods, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the McClellan Oscillator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double mcclOsc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, int shift) throws JFException;

    /**
     * Calculates the McClellan Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclOsc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the McClellan Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclOsc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the McClellan Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclOsc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the McClellan Summation Index for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double mcclSum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, int shift) throws JFException;

    /**
     * Calculates the McClellan Summation Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclSum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the McClellan Summation Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclSum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the McClellan Summation Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shortMAPeriods Short MA Periods
     * @param longMAPeriods Long MA Periods
     * @param maType MA Type
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mcclSum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shortMAPeriods, int longMAPeriods, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Median Price for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double medPrice(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Median Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] medPrice(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Median Price for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] medPrice(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Median Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] medPrice(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Money Flow Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double mfi(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Money Flow Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mfi(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Money Flow Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mfi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Money Flow Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mfi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the MidPoint over period for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double midPoint(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the MidPoint over period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] midPoint(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the MidPoint over period for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] midPoint(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the MidPoint over period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] midPoint(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Midpoint Price over period for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double midPrice(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Midpoint Price over period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] midPrice(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Midpoint Price over period for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] midPrice(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Midpoint Price over period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] midPrice(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the lowest value over a specified period for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double min(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the lowest value over a specified period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] min(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the lowest value over a specified period for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] min(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the lowest value over a specified period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] min(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

//    public int minIndex(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;
//    public int[] minIndex(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the lowest and the highest values over a specified period for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Min', 'Max'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/MinMax>MinMax indicator</a>
     */
    public double[] minMax(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the lowest and the highest values over a specified period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Min', 'Max' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] minMax(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the lowest and the highest values over a specified period for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Min', 'Max' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] minMax(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the lowest and the highest values over a specified period for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Min', 'Max' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] minMax(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

//    public int[] minMaxIndex(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;
//
//    public int[][] minMaxIndex(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Minus Directional Indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double minusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Minus Directional Indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] minusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Minus Directional Indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] minusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Minus Directional Indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] minusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Minus Directional Movement indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double minusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Minus Directional Movement indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] minusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Minus Directional Movement indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] minusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Minus Directional Movement indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] minusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Momentum indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double mom(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Momentum indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mom(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Momentum indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mom(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Momentum indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mom(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Mult for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double mult(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int shift) throws JFException;

    /**
     * Calculates the Vector Arithmetic Mult for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mult(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Mult for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mult(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Arithmetic Mult for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] mult(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2,
            AppliedPrice appliedPrice2, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param stepBack step back
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, int shift)}
     */
    public double[] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, int timePeriod, int stepBack, int shift) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param timePeriod time period
     * @param stepBack step back
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, long from, long to)}
     */
    public double[][] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, int timePeriod, int stepBack, long from, long to) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param timePeriod time period
     * @param stepBack step back
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, int timePeriod, int stepBack, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param timePeriod time period
     * @param stepBack step back
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, Filter filter, long from, long to)}
     */
    public double[][] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, int timePeriod, int stepBack, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param stepBack step back
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, int shift)}
     */
    public double[] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, int shift) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param stepBack step back
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, long from, long to)}
     */
    public double[][] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, long from, long to) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param stepBack step back
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param stepBack step back
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]',
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, Filter filter, long from, long to)}
     */
    public double[][] murrey(Instrument instrument, Period period, OfferSide side, int nPeriod, Period timePeriod, int stepBack, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period    
     * @param stepBack step back
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]', 
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, int shift) throws JFException;
    
    /**
     * Calculates the Murrey Channels indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period    
     * @param stepBack step back
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]', 
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, long from, long to) throws JFException;

    /**
     * Calculates the Murrey Channels indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period    
     * @param stepBack step back
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]', 
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'  
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Murrey Channels indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param nPeriod period    
     * @param stepBack step back
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '[-2/8P]', '[-1/8P]', '[0/8P]', '[1/8P]', '[2/8P]', '[3/8P]', 
     * '[4/8P]', '[5/8P]', '[6/8P]', '[7/8P]', '[8/8P]', '[+1/8P]', '[+2/8P]'  
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] murrey2(Instrument instrument, Period period, OfferSide side, int nPeriod, int stepBack, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Normalized Average True Range indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double natr(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Normalized Average True Range indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] natr(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Normalized Average True Range indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] natr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Normalized Average True Range indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] natr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the On Balance Volume for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param sideForPriceV Bid or Ask side for price volume
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double obv(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, OfferSide sideForPriceV, int shift) throws JFException;

    /**
     * Calculates the On Balance Volume for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param sideForPriceV Bid or Ask side for price volume
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] obv(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, OfferSide sideForPriceV, long from, long to) throws JFException;

    /**
     * Calculates the On Balance Volume for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param sideForPriceV Bid or Ask side for price volume
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] obv(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, OfferSide sideForPriceV, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the On Balance Volume for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param sideForPriceV Bid or Ask side for price volume
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] obv(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, OfferSide sideForPriceV, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Moving Average of Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fast_ema_period period for fast EMA
     * @param slow_ema_period period for slow EMA
     * @param signal_period signal period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double osma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fast_ema_period, int slow_ema_period, int signal_period, int shift) throws JFException;

    /**
     * Calculates the Moving Average of Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fast_ema_period period for fast EMA
     * @param slow_ema_period period for slow EMA
     * @param signal_period signal period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] osma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fast_ema_period, int slow_ema_period, int signal_period, long from, long to) throws JFException;

    /**
     * Calculates the Moving Average of Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fast_ema_period period for fast EMA
     * @param slow_ema_period period for slow EMA
     * @param signal_period signal period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] osma(Instrument instrument, Period period, OfferSide side, int fast_ema_period, int slow_ema_period, int signal_period, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Moving Average of Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fast_ema_period period for fast EMA
     * @param slow_ema_period period for slow EMA
     * @param signal_period signal period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] osma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fast_ema_period, int slow_ema_period, int signal_period, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param showHistoricalLevels show historical levels
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift)}
     */
    public double[] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, boolean showHistoricalLevels, int shift) throws JFException;

    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param showHistoricalLevels show historical levels
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, boolean showHistoricalLevels, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param showHistoricalLevels show historical levels
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, boolean showHistoricalLevels, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param showHistoricalLevels show historical levels
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, boolean showHistoricalLevels, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift)}
     */
    public double[] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod  value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot2(Instrument instrument, Period period, OfferSide side, int shift)}
     */
    public double[] pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift) throws JFException;

    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot2(Instrument instrument, Period period, OfferSide side, long from, long to)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2',
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #pivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to)}
     */
    public double[][] pivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2', 
     * 'Mid Point R2-R3', 'Mid Point S2-S3'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] pivot2(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2', 
     * 'Mid Point R2-R3', 'Mid Point S2-S3' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] pivot2(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Pivot points indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2', 
     * 'Mid Point R2-R3', 'Mid Point S2-S3'  
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] pivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Pivot points indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)', 'Support (S1)',
     * 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)', 'Mid Point P-R1', 'Mid Point P-S1', 'Mid Point R1-R2', 'Mid Point S1-S2', 
     * 'Mid Point R2-R3', 'Mid Point S2-S3'  
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] pivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Plus Directional Indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    
    public double plusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Plus Directional Indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] plusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Plus Directional Indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] plusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Plus Directional Indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] plusDi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Plus Directional Movement indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double plusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Plus Directional Movement indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] plusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Plus Directional Movement indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] plusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Plus Directional Movement indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] plusDm(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Percentage Price Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for fast MA
     * @param slowPeriod period for slow MA
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ppo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Percentage Price Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for fast MA
     * @param slowPeriod period for slow MA
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ppo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the Percentage Price Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for fast MA
     * @param slowPeriod period for slow MA
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ppo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Percentage Price Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for fast MA
     * @param slowPeriod period for slow MA
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ppo(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Price Channel indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for fast MA
     * @param slowPeriod period for slow MA
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #prchannel(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift)} 
     */     
    public double prchannel(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, int shift) throws JFException;

    /**
     * Calculates the Price Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for fast MA
     * @param slowPeriod period for slow MA
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #prchannel(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to)}
    */
    public double[] prchannel(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, long from, long to) throws JFException;

    /**
     * Calculates the Price Channel indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param fastPeriod period for fast MA
     * @param slowPeriod period for slow MA
     * @param maType {@link IIndicators.MaType type} of moving average
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @deprecated replaced by {@link #prchannel(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
    */
    public double[] prchannel(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int fastPeriod, int slowPeriod, MaType maType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Price Channel indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double prchannel(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Price Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] prchannel(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Price Channel indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] prchannel(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Price Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] prchannel(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Rank Correlation Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double rci(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Rank Correlation Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rci(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Rank Correlation Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rci(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Rank Correlation Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rci(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Regression Channel indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param degree value for degree parameter
     * @param kstd value for kstd parameter
     * @param bars number of used bars
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Regression Trend', 'Upper Line', 'Lower Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] regrChannel(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int degree, double kstd, int bars, int shift) throws JFException;

    /**
     * Calculates the Regression Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param degree value for degree parameter
     * @param kstd value for kstd parameter
     * @param bars number of used bars
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Regression Trend', 'Upper Line', 'Lower Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] regrChannel(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int degree, double kstd, int bars, long from, long to) throws JFException;

    /**
     * Calculates the Regression Channel indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param degree value for degree parameter
     * @param kstd value for kstd parameter
     * @param bars number of used bars
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Regression Trend', 'Upper Line', 'Lower Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] regrChannel(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int degree, double kstd, int bars, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Regression Channel indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param degree value for degree parameter
     * @param kstd value for kstd parameter
     * @param bars number of used bars
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Regression Trend', 'Upper Line', 'Lower Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] regrChannel(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int degree, double kstd, int bars, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Relative Momentum Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param momentumPeriod momentum period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double rmi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int momentumPeriod, int shift) throws JFException;

    /**
     * Calculates the Relative Momentum Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param momentumPeriod momentum period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rmi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int momentumPeriod, long from, long to) throws JFException;

    /**
     * Calculates the Relative Momentum Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param momentumPeriod momentum period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rmi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int momentumPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Relative Momentum Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param momentumPeriod momentum period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rmi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int momentumPeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double roc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Rate of change indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] roc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] roc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Rate of change indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] roc(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change Percentage indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double rocp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Rate of change Percentage indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change Percentage indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Rate of change Percentage indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change ratio: (price/prevPrice) for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double rocr(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Rate of change ratio: (price/prevPrice) for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocr(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change ratio: (price/prevPrice) for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocr(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Rate of change ratio: (price/prevPrice) for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocr(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change ratio 100 scale indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double rocr100(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Rate of change ratio 100 scale indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocr100(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Rate of change ratio 100 scale indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocr100(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Rate of change ratio 100 scale indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rocr100(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Relative Strength Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double rsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Relative Strength Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Relative Strength Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Relative Strength Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Relative Vigor Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'RVI', 'Signal Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] rvi(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Relative Vigor Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'RVI', 'Signal Line' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] rvi(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Relative Vigor Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'RVI', 'Signal Line' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] rvi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Relative Vigor Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'RVI', 'Signal Line' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] rvi(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Parabolic SAR indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param acceleration Acceleration Factor used up to the Maximum value
     * @param maximum Acceleration Factor Maximum value
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double sar(Instrument instrument, Period period, OfferSide side, double acceleration, double maximum, int shift) throws JFException;

    /**
     * Calculates the Parabolic SAR indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param acceleration Acceleration Factor used up to the Maximum value
     * @param maximum Acceleration Factor Maximum value
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sar(Instrument instrument, Period period, OfferSide side, double acceleration, double maximum, long from, long to) throws JFException;

    /**
     * Calculates the Parabolic SAR indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param acceleration Acceleration Factor used up to the Maximum value
     * @param maximum Acceleration Factor Maximum value
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sar(Instrument instrument, Period period, OfferSide side, double acceleration, double maximum, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Parabolic SAR indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param acceleration Acceleration Factor used up to the Maximum value
     * @param maximum Acceleration Factor Maximum value
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sar(Instrument instrument, Period period, OfferSide side, double acceleration, double maximum, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Parabolic SAR - Extended indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param startValue Start value and direction. 0 for Auto, &gt; 0 for Long, &lt; 0 for Short
     * @param offsetOnReverse Percent offset added/removed to initial stop on short/long reversal
     * @param accelerationInitLong Acceleration Factor initial value for the Long direction
     * @param accelerationLong Acceleration Factor for the Long direction
     * @param accelerationMaxLong Acceleration Factor maximum value for the Long direction
     * @param accelerationInitShort Acceleration Factor initial value for the Short direction
     * @param accelerationShort Acceleration Factor for the Short direction
     * @param accelerationMaxShort Acceleration Factor maximum value for the Short direction
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * <p>
     * Note! function returns negative values to show that position is short
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>     
     */
    public double sarExt(Instrument instrument, Period period, OfferSide side, double startValue, double offsetOnReverse, double accelerationInitLong, double accelerationLong, double accelerationMaxLong, double accelerationInitShort, double accelerationShort, double accelerationMaxShort, int shift) throws JFException;

    /**
     * Calculates the Parabolic SAR - Extended indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param startValue Start value and direction. 0 for Auto, &gt; 0 for Long, &lt; 0 for Short
     * @param offsetOnReverse Percent offset added/removed to initial stop on short/long reversal
     * @param accelerationInitLong Acceleration Factor initial value for the Long direction
     * @param accelerationLong Acceleration Factor for the Long direction
     * @param accelerationMaxLong Acceleration Factor maximum value for the Long direction
     * @param accelerationInitShort Acceleration Factor initial value for the Short direction
     * @param accelerationShort Acceleration Factor for the Short direction
     * @param accelerationMaxShort Acceleration Factor maximum value for the Short direction
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * <p>
     * Note! function returns negative values to show that position is short
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sarExt(Instrument instrument, Period period, OfferSide side, double startValue, double offsetOnReverse, double accelerationInitLong, double accelerationLong, double accelerationMaxLong, double accelerationInitShort, double accelerationShort, double accelerationMaxShort, long from, long to) throws JFException;

    /**
     * Calculates the Parabolic SAR - Extended indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param startValue Start value and direction. 0 for Auto, &gt; 0 for Long, &lt; 0 for Short
     * @param offsetOnReverse Percent offset added/removed to initial stop on short/long reversal
     * @param accelerationInitLong Acceleration Factor initial value for the Long direction
     * @param accelerationLong Acceleration Factor for the Long direction
     * @param accelerationMaxLong Acceleration Factor maximum value for the Long direction
     * @param accelerationInitShort Acceleration Factor initial value for the Short direction
     * @param accelerationShort Acceleration Factor for the Short direction
     * @param accelerationMaxShort Acceleration Factor maximum value for the Short direction
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sarExt(Instrument instrument, Period period, OfferSide side, double startValue, double offsetOnReverse, double accelerationInitLong, double accelerationLong, double accelerationMaxLong, double accelerationInitShort, double accelerationShort, double accelerationMaxShort, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Parabolic SAR - Extended indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param startValue Start value and direction. 0 for Auto, &gt; 0 for Long, &lt; 0 for Short
     * @param offsetOnReverse Percent offset added/removed to initial stop on short/long reversal
     * @param accelerationInitLong Acceleration Factor initial value for the Long direction
     * @param accelerationLong Acceleration Factor for the Long direction
     * @param accelerationMaxLong Acceleration Factor maximum value for the Long direction
     * @param accelerationInitShort Acceleration Factor initial value for the Short direction
     * @param accelerationShort Acceleration Factor for the Short direction
     * @param accelerationMaxShort Acceleration Factor maximum value for the Short direction
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * <p>
     * Note! function returns negative values to show that position is short
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sarExt(Instrument instrument, Period period, OfferSide side, double startValue, double offsetOnReverse, double accelerationInitLong, double accelerationLong, double accelerationMaxLong, double accelerationInitShort, double accelerationShort, double accelerationMaxShort, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Sin for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar 
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double sin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric Sin for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Sin for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric Sin for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sin(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to)throws JFException;

    /**
     * Calculates the Vector Trigonometric Sinh for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double sinh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric Sinh for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sinh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Sinh for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sinh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric Sinh for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sinh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Simple Moving Average for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double sma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Simple Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Simple Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Simple Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Stochastic Momentum Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod fast K period
     * @param slowKPeriod slow K period
     * @param slowDPeriod slow D period
     * @param smoothingPeriod smoothing period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'SMI', 'Signal'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] smi(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, int slowDPeriod, int smoothingPeriod, int shift) throws JFException;

    /**
     * Calculates the Stochastic Momentum Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod fast K period
     * @param slowKPeriod slow K period
     * @param slowDPeriod slow D period
     * @param smoothingPeriod smoothing period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'SMI', 'Signal' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] smi(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, int slowDPeriod, int smoothingPeriod, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic Momentum Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod fast K period
     * @param slowKPeriod slow K period
     * @param slowDPeriod slow D period
     * @param smoothingPeriod smoothing period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'SMI', 'Signal' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] smi(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, int slowDPeriod, int smoothingPeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Stochastic Momentum Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod fast K period
     * @param slowKPeriod slow K period
     * @param slowDPeriod slow D period
     * @param smoothingPeriod smoothing period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'SMI', 'Signal' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] smi(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, int slowDPeriod, int smoothingPeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Smoothed Moving Average indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double smma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Smoothed Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] smma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Smoothed Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] smma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Smoothed Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] smma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Square Root for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double sqrt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Square Root for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sqrt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Square Root for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sqrt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Square Root for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sqrt(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Standard Deviation for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Standard_Deviation>Standard Deviation</a>
     */
    public double stdDev(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, int shift) throws JFException;

    /**
     * Calculates the Standard Deviation for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Standard_Deviation>Standard Deviation</a>
     */
    public double[] stdDev(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, long from, long to) throws JFException;

    /**
     * Calculates the Standard Deviation for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Standard_Deviation>Standard Deviation</a>
     */
    public double[] stdDev(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Standard Deviation for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Standard_Deviation>Standard Deviation</a>
     */
    public double[] stdDev(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Slow %K', 'Slow %D'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[] stoch(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, int shift) throws JFException;

    /**
     * Calculates the Stochastic indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Slow %K', 'Slow %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[][] stoch(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Slow %K', 'Slow %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[][] stoch(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Stochastic indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Slow %K', 'Slow %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[][] stoch(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param priceType 0 - Low/High, 1 - Close
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Slow %K', 'Slow %D'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[] stochP(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, int priceType, int shift) throws JFException;

    /**
     * Calculates the Stochastic indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param priceType 0 - Low/High, 1 - Close
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Slow %K', 'Slow %D'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[][] stochP(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, int priceType, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param priceType 0 - Low/High, 1 - Close
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Slow %K', 'Slow %D'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[][] stochP(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, int priceType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Stochastic indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param slowKPeriod smoothing for making the Slow-K line. Usually set to 3
     * @param slowKMaType {@link IIndicators.MaType type} of moving average for Slow-K
     * @param slowDPeriod smoothing for making the Slow-D line
     * @param slowDMaType {@link IIndicators.MaType type} of moving average for Slow-D
     * @param priceType 0 - Low/High, 1 - Close
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Slow %K', 'Slow %D'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_catalog/Stochastic>Stochastic indicator</a>
     */
    public double[][] stochP(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, int priceType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic Fast indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType  {@link IIndicators.MaType type} of moving average for Fast-D
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Fast %K', 'Fast %D'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] stochF(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int fastDPeriod, MaType fastDMaType, int shift) throws JFException;

    /**
     * Calculates the Stochastic Fast indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType  {@link IIndicators.MaType type} of moving average for Fast-D
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Fast %K', 'Fast %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] stochF(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int fastDPeriod, MaType fastDMaType, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic Fast indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType  {@link IIndicators.MaType type} of moving average for Fast-D
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Fast %K', 'Fast %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] stochF(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int fastDPeriod, MaType fastDMaType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Stochastic Fast indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType  {@link IIndicators.MaType type} of moving average for Fast-D
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Fast %K', 'Fast %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] stochF(Instrument instrument, Period period, OfferSide side, int fastKPeriod, int fastDPeriod, MaType fastDMaType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic Relative Strength Index for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType {@link IIndicators.MaType type} of moving average for Fast-D
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Fast %K', 'Fast %D'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] stochRsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastKPeriod, int fastDPeriod, MaType fastDMaType, int shift) throws JFException;

    /**
     * Calculates the Stochastic Relative Strength Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType {@link IIndicators.MaType type} of moving average for Fast-D
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Fast %K', 'Fast %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] stochRsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastKPeriod, int fastDPeriod, MaType fastDMaType, long from, long to) throws JFException;

    /**
     * Calculates the Stochastic Relative Strength Index for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType {@link IIndicators.MaType type} of moving average for Fast-D
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Fast %K', 'Fast %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] stochRsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastKPeriod, int fastDPeriod, MaType fastDMaType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Stochastic Relative Strength Index for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param fastKPeriod time period for building the Fast-K line
     * @param fastDPeriod smoothing for making the Fast-D line. Usually set to 3
     * @param fastDMaType {@link IIndicators.MaType type} of moving average for Fast-D
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Fast %K', 'Fast %D' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] stochRsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int fastKPeriod, int fastDPeriod, MaType fastDMaType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Substraction for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double sub(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, int shift) throws JFException;

    /**
     * Calculates the Vector Arithmetic Substraction for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sub(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, long from, long to) throws JFException;

    /**
     * Calculates the Vector Arithmetic Substraction for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sub(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Arithmetic Substraction for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side1 Bid or Ask side of the bar for the first input parameter
     * @param appliedPrice1 {@link IIndicators.AppliedPrice type} of input data for the first input parameter
     * @param side2 Bid or Ask side of the bar for the second input parameter
     * @param appliedPrice2 {@link IIndicators.AppliedPrice type} of input data for the second input parameter
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sub(Instrument instrument, Period period, OfferSide side1, AppliedPrice appliedPrice1, OfferSide side2, AppliedPrice appliedPrice2, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Summation for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double sum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Summation for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Summation for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Summation for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] sum(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Support and Resistance indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Maximums', 'Minimums'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] supportResistance(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Support and Resistance indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Maximums', 'Minimums' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] supportResistance(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Support and Resistance indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Maximums', 'Minimums' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] supportResistance(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Support and Resistance indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Maximums', 'Minimums' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] supportResistance(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Triple Exponential Moving Average for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param vFactor volume Factor
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double t3(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double vFactor, int shift) throws JFException;

    /**
     * Calculates the Triple Exponential Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param vFactor volume Factor
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] t3(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double vFactor, long from, long to) throws JFException;

    /**
     * Calculates the Triple Exponential Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param vFactor volume Factor
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] t3(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double vFactor, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Triple Exponential Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param vFactor volume Factor
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] t3(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double vFactor, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Tan for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double tan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric Tan for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Tan for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric Tan for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tan(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Tanh for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double tanh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Vector Trigonometric Tanh for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tanh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Vector Trigonometric Tanh for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tanh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vector Trigonometric Tanh for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tanh(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Thrust Bar indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Thrust Bar Bullish Pattern', 'Thrust Bar Bearish Pattern',
     * 'Bullish FTS', 'Bullish LTS', 'Bearish FTS', 'Bearish LTS'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tbp(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Thrust Outside Bar indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Thrust Bar Bullish Pattern', 'Thrust Bar Bearish Pattern',
     * 'Bullish FTS', 'Bullish LTS', 'Bearish FTS', 'Bearish LTS'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tbop(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Tom DeMark Indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Line', 'Low Risk', 'High Risk'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] td_i(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Tom DeMark Indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Line', 'Low Risk', 'High Risk' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] td_i(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Tom DeMark Indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Line', 'Low Risk', 'High Risk' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] td_i(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Tom DeMark Indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Line', 'Low Risk', 'High Risk' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] td_i(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the TD Sequential indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Positive', 'Negative'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[] td_s(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the TD Sequential indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[][] td_s(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the TD Sequential indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[][] td_s(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the TD Sequential indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Positive', 'Negative' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public int[][] td_s(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Traders Dynamic Index indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param rsiPeriod RSI Period
     * @param rsiPriceLine RSI Price Line
     * @param priceMAType Price MA Type
     * @param tradeSignalLine Trade Signal Line
     * @param signalMAType Signal MA Type
     * @param volatilityBand Volatility Band
     * @param volatilityMAType Volatility MA Type
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'VB High', 'VB Low', 'Market Base Line', 'Trade Signal Line', 'RSI Price Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tdi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int rsiPeriod, int rsiPriceLine, MaType priceMAType, int tradeSignalLine, MaType signalMAType, int volatilityBand, MaType volatilityMAType, int shift) throws JFException;

    /**
     * Calculates the Traders Dynamic Index indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param rsiPeriod RSI Period
     * @param rsiPriceLine RSI Price Line
     * @param priceMAType Price MA Type
     * @param tradeSignalLine Trade Signal Line
     * @param signalMAType Signal MA Type
     * @param volatilityBand Volatility Band
     * @param volatilityMAType Volatility MA Type
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'VB High', 'VB Low', 'Market Base Line', 'Trade Signal Line', 'RSI Price Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] tdi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int rsiPeriod, int rsiPriceLine, MaType priceMAType, int tradeSignalLine, MaType signalMAType, int volatilityBand, MaType volatilityMAType, long from, long to) throws JFException;

    /**
     * Calculates the Traders Dynamic Index indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param rsiPeriod RSI Period
     * @param rsiPriceLine RSI Price Line
     * @param priceMAType Price MA Type
     * @param tradeSignalLine Trade Signal Line
     * @param signalMAType Signal MA Type
     * @param volatilityBand Volatility Band
     * @param volatilityMAType Volatility MA Type
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'VB High', 'VB Low', 'Market Base Line', 'Trade Signal Line', 'RSI Price Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] tdi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int rsiPeriod, int rsiPriceLine, MaType priceMAType, int tradeSignalLine, MaType signalMAType, int volatilityBand, MaType volatilityMAType, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Traders Dynamic Index indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param rsiPeriod RSI Period
     * @param rsiPriceLine RSI Price Line
     * @param priceMAType Price MA Type
     * @param tradeSignalLine Trade Signal Line
     * @param signalMAType Signal MA Type
     * @param volatilityBand Volatility Band
     * @param volatilityMAType Volatility MA Type
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'VB High', 'VB Low', 'Market Base Line', 'Trade Signal Line', 'RSI Price Line'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] tdi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int rsiPeriod, int rsiPriceLine, MaType priceMAType, int tradeSignalLine, MaType signalMAType, int volatilityBand, MaType volatilityMAType, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Triple Exponential Moving Average indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double tema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Triple Exponential Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Triple Exponential Moving Average indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Triple Exponential Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tema(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the True Range indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double trange(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the True Range indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trange(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the True Range indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trange(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the True Range indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trange(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Trend Envelope indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param deviation deviation
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Low Band', 'High Band'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trendEnv(Instrument instrument, Period period, OfferSide side, int timePeriod, double deviation, int shift) throws JFException;

    /**
     * Calculates the Trend Envelope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param deviation deviation
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] trendEnv(Instrument instrument, Period period, OfferSide side, int timePeriod,  double deviation, long from, long to) throws JFException;

    /**
     * Calculates the Trend Envelope indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param deviation deviation
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] trendEnv(Instrument instrument, Period period, OfferSide side, int timePeriod,  double deviation, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Trend Envelope indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param deviation deviation
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Low Band', 'High Band' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] trendEnv(Instrument instrument, Period period, OfferSide side, int timePeriod, double deviation, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Triangular Moving Average indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double trima(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Triangular Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trima(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Triangular Moving Average indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trima(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Triangular Moving Average indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trima(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the 1-day Rate-Of-Change (ROC) of a Triple Smooth EMA indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double trix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the 1-day Rate-Of-Change (ROC) of a Triple Smooth EMA indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the 1-day Rate-Of-Change (ROC) of a Triple Smooth EMA indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the 1-day Rate-Of-Change (ROC) of a Triple Smooth EMA indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] trix(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Time Series Forecast indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double tsf(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Time Series Forecast indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tsf(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Time Series Forecast indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tsf(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Time Series Forecast indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tsf(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the True Strength Index indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param smoothingPeriods Smoothing Periods
     * @param doubleSmoothingPeriods Double Smoothing Periods
     * @param signalLinePeriods Signal Line Periods
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'TSI', 'Signal Line', 'Histogram'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int smoothingPeriods, int doubleSmoothingPeriods, int signalLinePeriods, int shift) throws JFException;

    /**
     * Calculates the True Strength Index indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param smoothingPeriods Smoothing Periods
     * @param doubleSmoothingPeriods Double Smoothing Periods
     * @param signalLinePeriods Signal Line Periods
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'TSI', 'Signal Line', 'Histogram'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] tsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int smoothingPeriods, int doubleSmoothingPeriods, int signalLinePeriods, long from, long to) throws JFException;

    /**
     * Calculates the True Strength Index indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param smoothingPeriods Smoothing Periods
     * @param doubleSmoothingPeriods Double Smoothing Periods
     * @param signalLinePeriods Signal Line Periods
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'TSI', 'Signal Line', 'Histogram'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] tsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int smoothingPeriods, int doubleSmoothingPeriods, int signalLinePeriods, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the True Strength Index indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param smoothingPeriods Smoothing Periods
     * @param doubleSmoothingPeriods Double Smoothing Periods
     * @param signalLinePeriods Signal Line Periods
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'TSI', 'Signal Line', 'Histogram'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] tsi(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int smoothingPeriods, int doubleSmoothingPeriods, int signalLinePeriods, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Time Segmented Volume for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double tvs(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Time Segmented Volume for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tvs(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Time Segmented Volume for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tvs(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Time Segmented Volume for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] tvs(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Typical Price for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double typPrice(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Typical Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] typPrice(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Typical Price for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] typPrice(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Typical Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] typPrice(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Ultimate Oscillator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod1 number of bars for 1st period
     * @param timePeriod2 number of bars fro 2nd period
     * @param timePeriod3 number of bars for 3rd period 
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ultOsc(Instrument instrument, Period period, OfferSide side, int timePeriod1, int timePeriod2, int timePeriod3, int shift) throws JFException;

    /**
     * Calculates the Ultimate Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod1 number of bars for 1st period
     * @param timePeriod2 number of bars fro 2nd period
     * @param timePeriod3 number of bars for 3rd period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ultOsc(Instrument instrument, Period period, OfferSide side, int timePeriod1, int timePeriod2, int timePeriod3, long from, long to) throws JFException;

    /**
     * Calculates the Ultimate Oscillator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod1 number of bars for 1st period
     * @param timePeriod2 number of bars fro 2nd period
     * @param timePeriod3 number of bars for 3rd period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ultOsc(Instrument instrument, Period period, OfferSide side, int timePeriod1, int timePeriod2, int timePeriod3, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Ultimate Oscillator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod1 number of bars for 1st period
     * @param timePeriod2 number of bars fro 2nd period
     * @param timePeriod3 number of bars for 3rd period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ultOsc(Instrument instrument, Period period, OfferSide side, int timePeriod1, int timePeriod2, int timePeriod3, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Variance indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double var(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, int shift) throws JFException;

    /**
     * Calculates the Variance indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] var(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, long from, long to) throws JFException;

    /**
     * Calculates the Variance indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] var(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Variance indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param nbDev number of deviations
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] var(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, double nbDev, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates volume for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double volume(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates volume for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volume(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates volume for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volume(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates volume for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volume(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Volume Weighted Average Price for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double volumeWAP(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volumeWAP(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volumeWAP(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Volume Weighted Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volumeWAP(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double volumeWAP2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int shift) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volumeWAP2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, long from, long to) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volumeWAP2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] volumeWAP2(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double ticksVWAP(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ticksVWAP(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ticksVWAP(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Volume Weighted Average Price for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] ticksVWAP(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the Vortex indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar   
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: '+VM', '-VM'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] vortex(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Vortex indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar   
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '+VM', '-VM' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] vortex(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Vortex indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: '+VM', '-VM' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] vortex(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Vortex indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: '+VM', '-VM' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] vortex(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;   

    /**
     * Calculates the Waddah Attar Trend indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double waddahAttar(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Waddah Attar Trend indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] waddahAttar(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Waddah Attar Trend indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] waddahAttar(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    	
    /**
     * Calculates the Waddah Attar Trend indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] waddahAttar(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Weighted Close Price indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double wclPrice(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Weighted Close Price indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] wclPrice(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Weighted Close Price indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] wclPrice(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Weighted Close Price indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] wclPrice(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Williams' %R indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double willr(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Williams' %R indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] willr(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Williams' %R indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] willr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Williams' %R indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] willr(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Weighted Moving Average indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double wma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Weighted Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] wma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Weighted Moving Average for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] wma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Weighted Moving Average for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param appliedPrice {@link IIndicators.AppliedPrice type} of input data
     * @param timePeriod time period
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] wma(Instrument instrument, Period period, OfferSide side, AppliedPrice appliedPrice, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift)}
     */
    public double[] woodPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, int shift) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to)}
     */
    public double[][] woodPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] woodPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod value form 0 to 9 that describes the period used in the indicator. Periods are as follows:
     * <code>ONE_MIN, FIVE_MINS, TEN_MINS, FIFTEEN_MINS, THIRTY_MINS, ONE_HOUR, FOUR_HOURS, DAILY, WEEKLY, MONTHLY</code>
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to)}
     */
    public double[][] woodPivot(Instrument instrument, Period period, OfferSide side, int timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for a bar specified with the <code>shift</code> parameter.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot2(Instrument instrument, Period period, OfferSide side, int shift)}
     */
    public double[] woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, int shift) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot2(Instrument instrument, Period period, OfferSide side, long from, long to)}
     */
    public double[][] woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, long from, long to) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter)}
     */
    public double[][] woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars.
     * The resulting array for ticks is an array of values for 1 second bars.
     *
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param timePeriod one of the {@link Period#values() predefined} periods used in the indicator.
     * {@link Period#TICK} and {@link Period#ONE_YEAR} not supported.
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded.
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     * @deprecated replaced by {@link #woodPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to)}
     */
    public double[][] woodPivot(Instrument instrument, Period period, OfferSide side, Period timePeriod, Filter filter, long from, long to) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return values for the specified bar, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] woodPivot2(Instrument instrument, Period period, OfferSide side, int shift) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] woodPivot2(Instrument instrument, Period period, OfferSide side, long from, long to) throws JFException;

    /**
     * Calculates the Woodie Pivot indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)' 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] woodPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the Woodie Pivot indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars, outputs are returned in the following order: 'Central Point (P)', 'Resistance (R1)',
     * 'Support (S1)', 'Resistance (R2)', 'Support (S2)', 'Resistance (R3)', 'Support (S3)'  
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[][] woodPivot2(Instrument instrument, Period period, OfferSide side, Filter filter, long from, long to) throws JFException;
    
    /**
     * Calculates the ZigZag indicator for a bar specified with the <code>shift</code> parameter.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param extDepth depth
     * @param extDeviation deviation
     * @param extBackstep backstep
     * @param shift number of candles back in time starting from current bar. 0 - current bar (currently generated from ticks),
     *          1 - previous bar (last formed bar), 2 - current bar minus 2 bars and so on
     * @return value for the specified bar
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double zigzag(Instrument instrument, Period period, OfferSide side, int extDepth, int extDeviation, int extBackstep, int shift) throws JFException;

    /**
     * Calculates the ZigZag indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param extDepth depth
     * @param extDeviation deviation
     * @param extBackstep backstep
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] zigzag(Instrument instrument, Period period, OfferSide side, int extDepth, int extDeviation, int extBackstep, long from, long to) throws JFException;

    /**
     * Calculates the ZigZag indicator for bars specified with <code>numberOfCandlesBefore</code>, <code>time</code> and <code>numberOfCandlesAfter</code> parameters.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param extDepth depth
     * @param extDeviation deviation
     * @param extBackstep backstep
     * @param filter {@link Filter filter}
     * @param numberOfCandlesBefore how much candles to load before and including the candle with time specified in the <code>time</code> parameter
     * @param time time of the last candle in the period specified with the <code>numberOfCandlesBefore</code> parameter or/and
     *        time of the candle prior to the first candle in the period specified with the <code>numberOfCandlesAfter</code> parameter
     * @param numberOfCandlesAfter how much candles to load after (and not including) the candle with time specified in the <code>time</code> parameter
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] zigzag(Instrument instrument, Period period, OfferSide side, int extDepth, int extDeviation, int extBackstep, Filter filter, int numberOfCandlesBefore, long time, int numberOfCandlesAfter) throws JFException;
    
    /**
     * Calculates the ZigZag indicator for ticks or bars in the specified period. For ticks bars with 1 second period are calculated first
     * using the side specified in the <code>side</code> parameter, resulting data is calculated from these bars. 
     * The resulting array for ticks is an array of values for 1 second bars.
     * 
     * @param instrument instrument of the bar
     * @param period period of the bar
     * @param side Bid or Ask side of the bar
     * @param extDepth depth
     * @param extDeviation deviation
     * @param extBackstep backstep
     * @param filter {@link Filter filter}
     * @param from start of the time interval for which bars or ticks should be loaded. The value must be equal to the exact starting time of the bar for
     * the specified period. Method {@link IHistory#getBarStart(Period, long)} returns the starting time of the bar that includes
     * the specified time
     * @param to end time of the time interval for which bars or ticks should be loaded. 
     * This is the starting time of the last bar/tick that should be loaded
     * @return values for the specified bars 
     * @throws JFException when parameters are not valid
     * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation>Indicator calculation</a>
     */
    public double[] zigzag(Instrument instrument, Period period, OfferSide side, int extDepth, int extDeviation, int extBackstep, Filter filter, long from, long to) throws JFException;
    
	//ON-FEED METHODS START
	/**
	 * The True Range first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double trangeByShift = indicators.trange(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] trangeByTimeInterval = indicators.trange(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] trangeByCandleInterval = indicators.trange(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> trange(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Shooting Star first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlShootingStarByShift = indicators.cdlShootingStar(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlShootingStarByTimeInterval = indicators.cdlShootingStar(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlShootingStarByCandleInterval = indicators.cdlShootingStar(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlShootingStar(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Rate of change ratio 100 scale: (price/prevPrice)*100 first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double rocr100ByShift = indicators.rocr100(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(shift);
	 * double[] rocr100ByTimeInterval = indicators.rocr100(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(from, to);
	 * double[] rocr100ByCandleInterval = indicators.rocr100(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> rocr100(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Unique 3 River first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlUnique3RiverByShift = indicators.cdlUnique3River(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlUnique3RiverByTimeInterval = indicators.cdlUnique3River(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlUnique3RiverByCandleInterval = indicators.cdlUnique3River(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlUnique3River(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Advance Block first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlAdvanceBlockByShift = indicators.cdlAdvanceBlock(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlAdvanceBlockByTimeInterval = indicators.cdlAdvanceBlock(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlAdvanceBlockByCandleInterval = indicators.cdlAdvanceBlock(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlAdvanceBlock(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Heikin Ashi first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] heikenAshiByShift = indicators.heikenAshi(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] heikenAshiByTimeInterval = indicators.heikenAshi(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] heikenAshiByCandleInterval = indicators.heikenAshi(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> heikenAshi(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Harami Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHaramiByShift = indicators.cdlHarami(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHaramiByTimeInterval = indicators.cdlHarami(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHaramiByCandleInterval = indicators.cdlHarami(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHarami(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Median Price first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double medPriceByShift = indicators.medPrice(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] medPriceByTimeInterval = indicators.medPrice(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] medPriceByCandleInterval = indicators.medPrice(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> medPrice(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Linear Regression Angle first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double linearRegAngleByShift = indicators.linearRegAngle(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] linearRegAngleByTimeInterval = indicators.linearRegAngle(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] linearRegAngleByCandleInterval = indicators.linearRegAngle(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> linearRegAngle(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Triple Exponential Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double temaByShift = indicators.tema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] temaByTimeInterval = indicators.tema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] temaByCandleInterval = indicators.tema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> tema(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Laguerre-ACS1 first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double lagACS1ByShift = indicators.lagACS1(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 2, 0.6, 1000).calculate(shift);
	 * double[] lagACS1ByTimeInterval = indicators.lagACS1(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 2, 0.6, 1000).calculate(from, to);
	 * double[] lagACS1ByCandleInterval = indicators.lagACS1(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 2, 0.6, 1000).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param ma MA
	 * @param gamma gamma
	 * @param lookback lookback
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> lagACS1(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int ma, double gamma, int lookback);
	
	/**
	 * The Momentum first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double momByShift = indicators.mom(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(shift);
	 * double[] momByTimeInterval = indicators.mom(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(from, to);
	 * double[] momByCandleInterval = indicators.mom(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> mom(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Support and Resistance first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] supportResistanceByShift = indicators.supportResistance(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] supportResistanceByTimeInterval = indicators.supportResistance(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] supportResistanceByCandleInterval = indicators.supportResistance(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> supportResistance(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Moving average with variable period first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double mavpByShift = indicators.mavp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 2, 30, MaType.SMA).calculate(shift);
	 * double[] mavpByTimeInterval = indicators.mavp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 2, 30, MaType.SMA).calculate(from, to);
	 * double[] mavpByCandleInterval = indicators.mavp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 2, 30, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @param minPeriod Max period
	 * @param maxPeriod Min period
	 * @param maType MA type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> mavp(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2, int minPeriod, int maxPeriod, MaType maType);
	
	/**
	 * The Stochastic Fast first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] stochFByShift = indicators.stochF(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA).calculate(shift);
	 * double[][] stochFByTimeInterval = indicators.stochF(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA).calculate(from, to);
	 * double[][] stochFByCandleInterval = indicators.stochF(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param fastKPeriod Fast %K Period
	 * @param fastDPeriod Fast %D Period
	 * @param fastDMaType Fast %D MAType
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> stochF(IFeedDescriptor feedDescriptor, OfferSide side, int fastKPeriod, int fastDPeriod, MaType fastDMaType);
	
	/**
	 * The Vector Floor first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double floorByShift = indicators.floor(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] floorByTimeInterval = indicators.floor(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] floorByCandleInterval = indicators.floor(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> floor(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The PPO first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ppoByShift = indicators.ppo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, MaType.SMA).calculate(shift);
	 * double[] ppoByTimeInterval = indicators.ppo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, MaType.SMA).calculate(from, to);
	 * double[] ppoByCandleInterval = indicators.ppo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fastPeriod Fast period
	 * @param slowPeriod Slow period
	 * @param maType MA type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ppo(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fastPeriod, int slowPeriod, MaType maType);
	
	/**
	 * The Kicking - bull/bear determined by the longer marubozu first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlKickingByLengthByShift = indicators.cdlKickingByLength(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlKickingByLengthByTimeInterval = indicators.cdlKickingByLength(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlKickingByLengthByCandleInterval = indicators.cdlKickingByLength(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlKickingByLength(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Dark Cloud Cover first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlDarkCloudCoverByShift = indicators.cdlDarkCloudCover(feedDescriptor, OfferSide.BID, 0.5).calculate(shift);
	 * int[] cdlDarkCloudCoverByTimeInterval = indicators.cdlDarkCloudCover(feedDescriptor, OfferSide.BID, 0.5).calculate(from, to);
	 * int[] cdlDarkCloudCoverByCandleInterval = indicators.cdlDarkCloudCover(feedDescriptor, OfferSide.BID, 0.5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param penetration Penetration
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlDarkCloudCover(IFeedDescriptor feedDescriptor, OfferSide side, double penetration);
	
	/**
	 * The Two Crows first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdl2CrowsByShift = indicators.cdl2Crows(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdl2CrowsByTimeInterval = indicators.cdl2Crows(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdl2CrowsByCandleInterval = indicators.cdl2Crows(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdl2Crows(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Three Inside Up/Down first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdl3InsideByShift = indicators.cdl3Inside(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdl3InsideByTimeInterval = indicators.cdl3Inside(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdl3InsideByCandleInterval = indicators.cdl3Inside(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdl3Inside(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Average Directional Movement Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] dmiByShift = indicators.dmi(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[][] dmiByTimeInterval = indicators.dmi(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[][] dmiByCandleInterval = indicators.dmi(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Signal period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> dmi(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Directional Movement Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double dxByShift = indicators.dx(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] dxByTimeInterval = indicators.dx(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] dxByCandleInterval = indicators.dx(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> dx(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Time Series Forecast first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double tsfByShift = indicators.tsf(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] tsfByTimeInterval = indicators.tsf(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] tsfByCandleInterval = indicators.tsf(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> tsf(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Vector Ceil first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ceilByShift = indicators.ceil(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] ceilByTimeInterval = indicators.ceil(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] ceilByCandleInterval = indicators.ceil(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ceil(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Kicking first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlKickingByShift = indicators.cdlKicking(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlKickingByTimeInterval = indicators.cdlKicking(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlKickingByCandleInterval = indicators.cdlKicking(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlKicking(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Moving Average of Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double osmaByShift = indicators.osma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(shift);
	 * double[] osmaByTimeInterval = indicators.osma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(from, to);
	 * double[] osmaByCandleInterval = indicators.osma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fast_ema_period Fast period
	 * @param slow_ema_period Slow period
	 * @param signal_period Signal period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> osma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fast_ema_period, int slow_ema_period, int signal_period);
	
	/**
	 * The Upside Gap Two Crows first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlUpsideGap2CrowsByShift = indicators.cdlUpsideGap2Crows(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlUpsideGap2CrowsByTimeInterval = indicators.cdlUpsideGap2Crows(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlUpsideGap2CrowsByCandleInterval = indicators.cdlUpsideGap2Crows(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlUpsideGap2Crows(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Chande Momentum Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double cmoByShift = indicators.cmo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] cmoByTimeInterval = indicators.cmo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] cmoByCandleInterval = indicators.cmo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> cmo(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Takuri (Dragonfly Doji with very long lower shadow) first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlTakuriByShift = indicators.cdlTakuri(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlTakuriByTimeInterval = indicators.cdlTakuri(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlTakuriByCandleInterval = indicators.cdlTakuri(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlTakuri(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Beta first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double betaByShift = indicators.beta(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 5).calculate(shift);
	 * double[] betaByTimeInterval = indicators.beta(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 5).calculate(from, to);
	 * double[] betaByCandleInterval = indicators.beta(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> beta(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2, int timePeriod);
	
	/**
	 * The MA Envelope first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] maEnvelopeByShift = indicators.maEnvelope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 0.1).calculate(shift);
	 * double[][] maEnvelopeByTimeInterval = indicators.maEnvelope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 0.1).calculate(from, to);
	 * double[][] maEnvelopeByCandleInterval = indicators.maEnvelope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 0.1).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @param deviation Deviation
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> maEnvelope(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, double deviation);
	
	/**
	 * The Pivot first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] pivotByShift = indicators.pivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(shift);
	 * double[][] pivotByTimeInterval = indicators.pivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(from, to);
	 * double[][] pivotByCandleInterval = indicators.pivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	@Deprecated
	IIndicatorCalculator<double[], double[][]> pivot(IFeedDescriptor feedDescriptor, OfferSide side, Period timePeriod);
	
	/**
	 * The Pivot first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] pivot2ByShift = indicators.pivot2(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] pivot2ByTimeInterval = indicators.pivot2(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] pivot2ByCandleInterval = indicators.pivot2(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> pivot2(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Concealing Baby Swallow first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlConcealBabySwallByShift = indicators.cdlConcealBabySwall(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlConcealBabySwallByTimeInterval = indicators.cdlConcealBabySwall(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlConcealBabySwallByCandleInterval = indicators.cdlConcealBabySwall(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlConcealBabySwall(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Matching Low first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlMatchingLowByShift = indicators.cdlMatchingLow(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlMatchingLowByTimeInterval = indicators.cdlMatchingLow(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlMatchingLowByCandleInterval = indicators.cdlMatchingLow(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlMatchingLow(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Gravestone Doji first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlGravestoneDojiByShift = indicators.cdlGravestoneDoji(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlGravestoneDojiByTimeInterval = indicators.cdlGravestoneDoji(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlGravestoneDojiByCandleInterval = indicators.cdlGravestoneDoji(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlGravestoneDoji(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Camarilla Pivots first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] camPivotByShift = indicators.camPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(shift);
	 * double[][] camPivotByTimeInterval = indicators.camPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(from, to);
	 * double[][] camPivotByCandleInterval = indicators.camPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	@Deprecated
	IIndicatorCalculator<double[], double[][]> camPivot(IFeedDescriptor feedDescriptor, OfferSide side, Period timePeriod);
	
	/**
	 * The Camarilla Pivots first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] camPivot2ByShift = indicators.camPivot2(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] camPivot2ByTimeInterval = indicators.camPivot2(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] camPivot2ByCandleInterval = indicators.camPivot2(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> camPivot2(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Doji first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlDojiByShift = indicators.cdlDoji(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlDojiByTimeInterval = indicators.cdlDoji(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlDojiByCandleInterval = indicators.cdlDoji(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlDoji(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Bear Power first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double bearByShift = indicators.bear(feedDescriptor, OfferSide.BID, 13).calculate(shift);
	 * double[] bearByTimeInterval = indicators.bear(feedDescriptor, OfferSide.BID, 13).calculate(from, to);
	 * double[] bearByCandleInterval = indicators.bear(feedDescriptor, OfferSide.BID, 13).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> bear(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Relative Vigor Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] rviByShift = indicators.rvi(feedDescriptor, OfferSide.BID, 10).calculate(shift);
	 * double[][] rviByTimeInterval = indicators.rvi(feedDescriptor, OfferSide.BID, 10).calculate(from, to);
	 * double[][] rviByCandleInterval = indicators.rvi(feedDescriptor, OfferSide.BID, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> rvi(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Thrust Outside Bar first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * //Only calculation by shift
	 * double[] tbopByShift = indicators.tbop(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> tbop(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Highest value over a specified period first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double maxByShift = indicators.max(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] maxByTimeInterval = indicators.max(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] maxByCandleInterval = indicators.max(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> max(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Vector Square Root first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double sqrtByShift = indicators.sqrt(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] sqrtByTimeInterval = indicators.sqrt(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] sqrtByCandleInterval = indicators.sqrt(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sqrt(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Bull Power first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double bullByShift = indicators.bull(feedDescriptor, OfferSide.BID, 13).calculate(shift);
	 * double[] bullByTimeInterval = indicators.bull(feedDescriptor, OfferSide.BID, 13).calculate(from, to);
	 * double[] bullByCandleInterval = indicators.bull(feedDescriptor, OfferSide.BID, 13).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> bull(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Engulfing Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlEngulfingByShift = indicators.cdlEngulfing(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlEngulfingByTimeInterval = indicators.cdlEngulfing(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlEngulfingByCandleInterval = indicators.cdlEngulfing(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlEngulfing(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vector Trigonometric Sin first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double sinByShift = indicators.sin(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] sinByTimeInterval = indicators.sin(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] sinByCandleInterval = indicators.sin(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sin(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Average Directional Movement Index Rating first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double adxrByShift = indicators.adxr(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] adxrByTimeInterval = indicators.adxr(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] adxrByCandleInterval = indicators.adxr(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> adxr(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Center of gravity first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] cogByShift = indicators.cog(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10, 3, MaType.SMA).calculate(shift);
	 * double[][] cogByTimeInterval = indicators.cog(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10, 3, MaType.SMA).calculate(from, to);
	 * double[][] cogByCandleInterval = indicators.cog(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10, 3, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @param smoothPeriod Smooth period
	 * @param maType Smooth type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> cog(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, int smoothPeriod, MaType maType);
	
	/**
	 * The Volumes first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double volumeByShift = indicators.volume(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] volumeByTimeInterval = indicators.volume(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] volumeByCandleInterval = indicators.volume(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> volume(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Breakaway first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlBreakAwayByShift = indicators.cdlBreakAway(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlBreakAwayByTimeInterval = indicators.cdlBreakAway(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlBreakAwayByCandleInterval = indicators.cdlBreakAway(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlBreakAway(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Standard Deviation first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double stdDevByShift = indicators.stdDev(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 1.0).calculate(shift);
	 * double[] stdDevByTimeInterval = indicators.stdDev(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 1.0).calculate(from, to);
	 * double[] stdDevByCandleInterval = indicators.stdDev(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 1.0).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @param nbDev Nb Dev
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> stdDev(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, double nbDev);
	
	/**
	 * The Hanging Man first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHangingManByShift = indicators.cdlHangingMan(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHangingManByTimeInterval = indicators.cdlHangingMan(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHangingManByCandleInterval = indicators.cdlHangingMan(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHangingMan(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Relative Strength Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double rsiByShift = indicators.rsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] rsiByTimeInterval = indicators.rsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] rsiByCandleInterval = indicators.rsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> rsi(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Vector Trigonometric Cos first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double cosByShift = indicators.cos(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] cosByTimeInterval = indicators.cos(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] cosByCandleInterval = indicators.cos(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> cos(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Volume Weighted Average Price first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double volumeWAPByShift = indicators.volumeWAP(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 4).calculate(shift);
	 * double[] volumeWAPByTimeInterval = indicators.volumeWAP(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 4).calculate(from, to);
	 * double[] volumeWAPByCandleInterval = indicators.volumeWAP(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 4).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> volumeWAP(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Volume Weighted Average Price first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double volumeWAP2ByShift = indicators.volumeWAP2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] volumeWAP2ByTimeInterval = indicators.volumeWAP2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] volumeWAP2ByCandleInterval = indicators.volumeWAP2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> volumeWAP2(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Volume Weighted Average Price first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ticksVWAPByShift = indicators.ticksVWAP(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] ticksVWAPByTimeInterval = indicators.ticksVWAP(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] ticksVWAPByCandleInterval = indicators.ticksVWAP(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ticksVWAP(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The MidPoint over period first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double midPointByShift = indicators.midPoint(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] midPointByTimeInterval = indicators.midPoint(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] midPointByCandleInterval = indicators.midPoint(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> midPoint(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Hilbert Transform - Dominant Cycle Period first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ht_dcperiodByShift = indicators.ht_dcperiod(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] ht_dcperiodByTimeInterval = indicators.ht_dcperiod(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] ht_dcperiodByCandleInterval = indicators.ht_dcperiod(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ht_dcperiod(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Plus Directional Movement first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double plusDmByShift = indicators.plusDm(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] plusDmByTimeInterval = indicators.plusDm(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] plusDmByCandleInterval = indicators.plusDm(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> plusDm(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Vector Trigonometric Tanh first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double tanhByShift = indicators.tanh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] tanhByTimeInterval = indicators.tanh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] tanhByCandleInterval = indicators.tanh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> tanh(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The On Balance Volume first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double obvByShift = indicators.obv(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] obvByTimeInterval = indicators.obv(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] obvByCandleInterval = indicators.obv(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> obv(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2);
	
	/**
	 * The Tom DeMark Indicator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] td_iByShift = indicators.td_i(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[][] td_iByTimeInterval = indicators.td_i(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[][] td_iByCandleInterval = indicators.td_i(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> td_i(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Spinning Top first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlSpinningTopByShift = indicators.cdlSpinningTop(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlSpinningTopByTimeInterval = indicators.cdlSpinningTop(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlSpinningTopByCandleInterval = indicators.cdlSpinningTop(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlSpinningTop(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Three Black Crows first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdl3BlackCrowsByShift = indicators.cdl3BlackCrows(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdl3BlackCrowsByTimeInterval = indicators.cdl3BlackCrows(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdl3BlackCrowsByCandleInterval = indicators.cdl3BlackCrows(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdl3BlackCrows(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Woodie Pivot first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] woodPivotByShift = indicators.woodPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(shift);
	 * double[][] woodPivotByTimeInterval = indicators.woodPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(from, to);
	 * double[][] woodPivotByCandleInterval = indicators.woodPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	@Deprecated
	IIndicatorCalculator<double[], double[][]> woodPivot(IFeedDescriptor feedDescriptor, OfferSide side, Period timePeriod);
	
	/**
	 * The Woodie Pivot first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] woodPivot2ByShift = indicators.woodPivot2(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] woodPivot2ByTimeInterval = indicators.woodPivot2(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] woodPivot2ByCandleInterval = indicators.woodPivot2(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> woodPivot2(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Piercing Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlPiercingByShift = indicators.cdlPiercing(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlPiercingByTimeInterval = indicators.cdlPiercing(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlPiercingByCandleInterval = indicators.cdlPiercing(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlPiercing(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vector Trigonometric Cosh first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double coshByShift = indicators.cosh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] coshByTimeInterval = indicators.cosh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] coshByCandleInterval = indicators.cosh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> cosh(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Minus Directional Indicator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double minusDiByShift = indicators.minusDi(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] minusDiByTimeInterval = indicators.minusDi(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] minusDiByCandleInterval = indicators.minusDi(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> minusDi(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Morning Star first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlMorningStarByShift = indicators.cdlMorningStar(feedDescriptor, OfferSide.BID, 0.3).calculate(shift);
	 * int[] cdlMorningStarByTimeInterval = indicators.cdlMorningStar(feedDescriptor, OfferSide.BID, 0.3).calculate(from, to);
	 * int[] cdlMorningStarByCandleInterval = indicators.cdlMorningStar(feedDescriptor, OfferSide.BID, 0.3).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param penetration Penetration
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlMorningStar(IFeedDescriptor feedDescriptor, OfferSide side, double penetration);
	
	/**
	 * The Modified Hikkake Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHikkakeModByShift = indicators.cdlHikkakeMod(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHikkakeModByTimeInterval = indicators.cdlHikkakeMod(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHikkakeModByCandleInterval = indicators.cdlHikkakeMod(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHikkakeMod(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Minus Directional Movement first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double minusDmByShift = indicators.minusDm(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] minusDmByTimeInterval = indicators.minusDm(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] minusDmByCandleInterval = indicators.minusDm(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> minusDm(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The ZigZag first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double zigzagByShift = indicators.zigzag(feedDescriptor, OfferSide.BID, 12, 5, 3).calculate(shift);
	 * double[] zigzagByTimeInterval = indicators.zigzag(feedDescriptor, OfferSide.BID, 12, 5, 3).calculate(from, to);
	 * double[] zigzagByCandleInterval = indicators.zigzag(feedDescriptor, OfferSide.BID, 12, 5, 3).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param extDepth ExtDepth
	 * @param extDeviation ExtDeviation
	 * @param extBackstep ExtBackstep
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> zigzag(IFeedDescriptor feedDescriptor, OfferSide side, int extDepth, int extDeviation, int extBackstep);
	
	/**
	 * The TD Sequential first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int[] td_sByShift = indicators.td_s(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 4).calculate(shift);
	 * int[][] td_sByTimeInterval = indicators.td_s(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 4).calculate(from, to);
	 * int[][] td_sByCandleInterval = indicators.td_s(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 4).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<int[], int[][]> td_s(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The In-Neck Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlInNeckByShift = indicators.cdlInNeck(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlInNeckByTimeInterval = indicators.cdlInNeck(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlInNeckByCandleInterval = indicators.cdlInNeck(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlInNeck(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Stochastic Relative Strength Indicator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] stochRsiByShift = indicators.stochRsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 5, 3, MaType.SMA).calculate(shift);
	 * double[][] stochRsiByTimeInterval = indicators.stochRsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 5, 3, MaType.SMA).calculate(from, to);
	 * double[][] stochRsiByCandleInterval = indicators.stochRsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 5, 3, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @param fastKPeriod Fast %K Period
	 * @param fastDPeriod Fast %D Period
	 * @param fastDMaType Fast %D MAType
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> stochRsi(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, int fastKPeriod, int fastDPeriod, MaType fastDMaType);
	
	/**
	 * The Average Price first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double avgPriceByShift = indicators.avgPrice(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] avgPriceByTimeInterval = indicators.avgPrice(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] avgPriceByCandleInterval = indicators.avgPrice(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> avgPrice(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Waddah Attar Trend first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double waddahAttarByShift = indicators.waddahAttar(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] waddahAttarByTimeInterval = indicators.waddahAttar(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] waddahAttarByCandleInterval = indicators.waddahAttar(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> waddahAttar(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Midpoint Price over period first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double midPriceByShift = indicators.midPrice(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] midPriceByTimeInterval = indicators.midPrice(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] midPriceByCandleInterval = indicators.midPrice(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> midPrice(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Rank Correlation Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double rciByShift = indicators.rci(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] rciByTimeInterval = indicators.rci(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] rciByCandleInterval = indicators.rci(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> rci(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Separating Lines first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlSeparatingLinesByShift = indicators.cdlSeparatingLines(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlSeparatingLinesByTimeInterval = indicators.cdlSeparatingLines(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlSeparatingLinesByCandleInterval = indicators.cdlSeparatingLines(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlSeparatingLines(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Pearson's Correlation Coefficient(r) first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double correlByShift = indicators.correl(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] correlByTimeInterval = indicators.correl(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] correlByCandleInterval = indicators.correl(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> correl(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2, int timePeriod);
	
	/**
	 * The Triple Exponential Moving Average (T3) first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double t3ByShift = indicators.t3(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 0.7).calculate(shift);
	 * double[] t3ByTimeInterval = indicators.t3(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 0.7).calculate(from, to);
	 * double[] t3ByCandleInterval = indicators.t3(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 0.7).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @param factor V Factor
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> t3(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, double factor);
	
	/**
	 * The Up/Down-gap side-by-side white lines first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlGapSideSideWhiteByShift = indicators.cdlGapSideSideWhite(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlGapSideSideWhiteByTimeInterval = indicators.cdlGapSideSideWhite(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlGapSideSideWhiteByCandleInterval = indicators.cdlGapSideSideWhite(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlGapSideSideWhite(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vector Arithmetic Substraction first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double subByShift = indicators.sub(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] subByTimeInterval = indicators.sub(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] subByCandleInterval = indicators.sub(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sub(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2);
	
	/**
	 * The Vector Trigonometric ASin first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double asinByShift = indicators.asin(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] asinByTimeInterval = indicators.asin(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] asinByCandleInterval = indicators.asin(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> asin(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Variance first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double varByShift = indicators.var(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 1.0).calculate(shift);
	 * double[] varByTimeInterval = indicators.var(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 1.0).calculate(from, to);
	 * double[] varByCandleInterval = indicators.var(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 1.0).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @param nbDev Nb Dev
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> var(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, double nbDev);
	
	/**
	 * The Hilbert Transform - SineWave first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] ht_sineByShift = indicators.ht_sine(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[][] ht_sineByTimeInterval = indicators.ht_sine(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[][] ht_sineByCandleInterval = indicators.ht_sine(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> ht_sine(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Summation first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double sumByShift = indicators.sum(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] sumByTimeInterval = indicators.sum(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] sumByCandleInterval = indicators.sum(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sum(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Linear Weighted Moving Average (LWMA) first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double lwmaByShift = indicators.lwma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] lwmaByTimeInterval = indicators.lwma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] lwmaByCandleInterval = indicators.lwma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> lwma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Laguerre-ACS1 first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double lasacs1ByShift = indicators.lasacs1(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 2, 0.6, 1000).calculate(shift);
	 * double[] lasacs1ByTimeInterval = indicators.lasacs1(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 2, 0.6, 1000).calculate(from, to);
	 * double[] lasacs1ByCandleInterval = indicators.lasacs1(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 2, 0.6, 1000).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param ma MA
	 * @param gamma gamma
	 * @param lookback lookback
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> lasacs1(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int ma, double gamma, int lookback);
	
	/**
	 * The Three-Line Strike  first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdl3LineStrikeByShift = indicators.cdl3LineStrike(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdl3LineStrikeByTimeInterval = indicators.cdl3LineStrike(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdl3LineStrikeByCandleInterval = indicators.cdl3LineStrike(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdl3LineStrike(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Hilbert Transform - Instantaneous Trendline first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ht_trendlineByShift = indicators.ht_trendline(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] ht_trendlineByTimeInterval = indicators.ht_trendline(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] ht_trendlineByCandleInterval = indicators.ht_trendline(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ht_trendline(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Counterattack first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlCounterattackByShift = indicators.cdlCounterattack(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlCounterattackByTimeInterval = indicators.cdlCounterattack(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlCounterattackByCandleInterval = indicators.cdlCounterattack(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlCounterattack(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The 1-day Rate-Of-Change (ROC) of a Triple Smooth EMA first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double trixByShift = indicators.trix(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] trixByTimeInterval = indicators.trix(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] trixByCandleInterval = indicators.trix(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> trix(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Harami Cross Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHaramiCrossByShift = indicators.cdlHaramiCross(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHaramiCrossByTimeInterval = indicators.cdlHaramiCross(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHaramiCrossByCandleInterval = indicators.cdlHaramiCross(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHaramiCross(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Linear Regression Intercept first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double linearRegInterceptByShift = indicators.linearRegIntercept(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] linearRegInterceptByTimeInterval = indicators.linearRegIntercept(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] linearRegInterceptByCandleInterval = indicators.linearRegIntercept(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> linearRegIntercept(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Keltner Channel first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] keltnerByShift = indicators.keltner(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(shift);
	 * double[][] keltnerByTimeInterval = indicators.keltner(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(from, to);
	 * double[][] keltnerByCandleInterval = indicators.keltner(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> keltner(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Gator Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] gatorByShift = indicators.gator(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 8, 5).calculate(shift);
	 * double[][] gatorByTimeInterval = indicators.gator(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 8, 5).calculate(from, to);
	 * double[][] gatorByCandleInterval = indicators.gator(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 8, 5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param jawTimePeriod Jaw Time Period
	 * @param teethTimePeriod Teeth Time Period
	 * @param lipsTimePeriod Lips Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> gator(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod);
	
	/**
	 * The Stick Sandwich first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlStickSandwichByShift = indicators.cdlStickSandwich(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlStickSandwichByTimeInterval = indicators.cdlStickSandwich(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlStickSandwichByCandleInterval = indicators.cdlStickSandwich(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlStickSandwich(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vortex indicator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] vortexByShift = indicators.vortex(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[][] vortexByTimeInterval = indicators.vortex(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[][] vortexByCandleInterval = indicators.vortex(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> vortex(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Balance Of Power first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double bopByShift = indicators.bop(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] bopByTimeInterval = indicators.bop(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] bopByCandleInterval = indicators.bop(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> bop(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Plus Directional Indicator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double plusDiByShift = indicators.plusDi(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] plusDiByTimeInterval = indicators.plusDi(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] plusDiByCandleInterval = indicators.plusDi(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> plusDi(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Random Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] kdjByShift = indicators.kdj(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA, -2.0, 3.0).calculate(shift);
	 * double[][] kdjByTimeInterval = indicators.kdj(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA, -2.0, 3.0).calculate(from, to);
	 * double[][] kdjByCandleInterval = indicators.kdj(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA, -2.0, 3.0).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param fastKPeriod Fast %K Period
	 * @param slowKPeriod Slow %K Period
	 * @param slowKMaType Slow %K MAType
	 * @param slowDPeriod Slow %D Period
	 * @param slowDMaType Slow %D MAType
	 * @param kMultiplier %K Multiplier
	 * @param dMultiplier %D Multiplier
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> kdj(IFeedDescriptor feedDescriptor, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, double kMultiplier, double dMultiplier);
	
	/**
	 * The Tristar Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlTristarByShift = indicators.cdlTristar(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlTristarByTimeInterval = indicators.cdlTristar(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlTristarByCandleInterval = indicators.cdlTristar(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlTristar(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Chaikin A/D Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double adOscByShift = indicators.adOsc(feedDescriptor, OfferSide.BID, 3, 10).calculate(shift);
	 * double[] adOscByTimeInterval = indicators.adOsc(feedDescriptor, OfferSide.BID, 3, 10).calculate(from, to);
	 * double[] adOscByCandleInterval = indicators.adOsc(feedDescriptor, OfferSide.BID, 3, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param fastPeriod Fast Period
	 * @param slowPeriod Slow Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> adOsc(IFeedDescriptor feedDescriptor, OfferSide side, int fastPeriod, int slowPeriod);
	
	/**
	 * The Accelerator/Decelerator Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] acByShift = indicators.ac(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 34).calculate(shift);
	 * double[][] acByTimeInterval = indicators.ac(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 34).calculate(from, to);
	 * double[][] acByCandleInterval = indicators.ac(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 34).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fastPeriod Fast Period
	 * @param slowPeriod Slow Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	@Deprecated
	IIndicatorCalculator<double[], double[][]> ac(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fastPeriod, int slowPeriod);
	
	/**
	 * The Accelerator/Decelerator Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ac2ByShift = indicators.ac2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 34).calculate(shift);
	 * double[] ac2ByTimeInterval = indicators.ac2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 34).calculate(from, to);
	 * double[] ac2ByCandleInterval = indicators.ac2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, 34).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fastPeriod Fast Period
	 * @param slowPeriod Slow Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ac2(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fastPeriod, int slowPeriod);
	
	/**
	 * The Chaikin A/D Line first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double adByShift = indicators.ad(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] adByTimeInterval = indicators.ad(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] adByCandleInterval = indicators.ad(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ad(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Identical Three Crows first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlIdentical3CrowsByShift = indicators.cdlIdentical3Crows(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlIdentical3CrowsByTimeInterval = indicators.cdlIdentical3Crows(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlIdentical3CrowsByCandleInterval = indicators.cdlIdentical3Crows(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlIdentical3Crows(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Closing Marubozu first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlClosingMarubozuByShift = indicators.cdlClosingMarubozu(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlClosingMarubozuByTimeInterval = indicators.cdlClosingMarubozu(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlClosingMarubozuByCandleInterval = indicators.cdlClosingMarubozu(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlClosingMarubozu(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The High-Wave Candle first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHighWaveByShift = indicators.cdlHighWave(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHighWaveByTimeInterval = indicators.cdlHighWave(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHighWaveByCandleInterval = indicators.cdlHighWave(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHighWave(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Morning Doji Star first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlMorningDojiStarByShift = indicators.cdlMorningDojiStar(feedDescriptor, OfferSide.BID, 5).calculate(shift);
	 * int[] cdlMorningDojiStarByTimeInterval = indicators.cdlMorningDojiStar(feedDescriptor, OfferSide.BID, 5).calculate(from, to);
	 * int[] cdlMorningDojiStarByCandleInterval = indicators.cdlMorningDojiStar(feedDescriptor, OfferSide.BID, 5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param penetration Nothing
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlMorningDojiStar(IFeedDescriptor feedDescriptor, OfferSide side, double penetration);
	
	/**
	 * The Triangular Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double trimaByShift = indicators.trima(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] trimaByTimeInterval = indicators.trima(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] trimaByCandleInterval = indicators.trima(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> trima(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Money Flow Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double mfiByShift = indicators.mfi(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] mfiByTimeInterval = indicators.mfi(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] mfiByCandleInterval = indicators.mfi(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> mfi(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Rate of change ratio: (price/prevPrice) first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double rocrByShift = indicators.rocr(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(shift);
	 * double[] rocrByTimeInterval = indicators.rocr(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(from, to);
	 * double[] rocrByCandleInterval = indicators.rocr(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> rocr(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Marubozu first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlMarubozuByShift = indicators.cdlMarubozu(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlMarubozuByTimeInterval = indicators.cdlMarubozu(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlMarubozuByCandleInterval = indicators.cdlMarubozu(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlMarubozu(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Rate of change Percentage: (price-prevPrice)/prevPrice first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double rocpByShift = indicators.rocp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(shift);
	 * double[] rocpByTimeInterval = indicators.rocp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(from, to);
	 * double[] rocpByCandleInterval = indicators.rocp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> rocp(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Doji Star first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlDojiStarByShift = indicators.cdlDojiStar(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlDojiStarByTimeInterval = indicators.cdlDojiStar(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlDojiStarByCandleInterval = indicators.cdlDojiStar(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlDojiStar(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Weighted Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double wmaByShift = indicators.wma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] wmaByTimeInterval = indicators.wma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] wmaByCandleInterval = indicators.wma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> wma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Trend Envelope first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] trendEnvByShift = indicators.trendEnv(feedDescriptor, OfferSide.BID, 14, 0.1).calculate(shift);
	 * double[][] trendEnvByTimeInterval = indicators.trendEnv(feedDescriptor, OfferSide.BID, 14, 0.1).calculate(from, to);
	 * double[][] trendEnvByCandleInterval = indicators.trendEnv(feedDescriptor, OfferSide.BID, 14, 0.1).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @param deviation Deviation
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> trendEnv(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod, double deviation);
	
	/**
	 * The Linear Regression Slope first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double linearRegSlopeByShift = indicators.linearRegSlope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] linearRegSlopeByTimeInterval = indicators.linearRegSlope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] linearRegSlopeByCandleInterval = indicators.linearRegSlope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> linearRegSlope(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Smoothed Moving Average (SMMA) first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double smmaByShift = indicators.smma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] smmaByTimeInterval = indicators.smma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] smmaByCandleInterval = indicators.smma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> smma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Mat Hold first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlMatholdByShift = indicators.cdlMathold(feedDescriptor, OfferSide.BID, 0.5).calculate(shift);
	 * int[] cdlMatholdByTimeInterval = indicators.cdlMathold(feedDescriptor, OfferSide.BID, 0.5).calculate(from, to);
	 * int[] cdlMatholdByCandleInterval = indicators.cdlMathold(feedDescriptor, OfferSide.BID, 0.5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param penetration Penetration
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlMathold(IFeedDescriptor feedDescriptor, OfferSide side, double penetration);
	
	/**
	 * The Commodity Channel Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double cciByShift = indicators.cci(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] cciByTimeInterval = indicators.cci(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] cciByCandleInterval = indicators.cci(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> cci(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Stalled Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlStalledPatternByShift = indicators.cdlStalledPattern(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlStalledPatternByTimeInterval = indicators.cdlStalledPattern(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlStalledPatternByCandleInterval = indicators.cdlStalledPattern(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlStalledPattern(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Moving Average Convergence/Divergence Fix 12/26 first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] macdFixByShift = indicators.macdFix(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 9).calculate(shift);
	 * double[][] macdFixByTimeInterval = indicators.macdFix(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 9).calculate(from, to);
	 * double[][] macdFixByCandleInterval = indicators.macdFix(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 9).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param signalPeriod Signal Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> macdFix(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int signalPeriod);
	
	/**
	 * The Awesome Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] awesomeByShift = indicators.awesome(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, MaType.SMA, 34, MaType.SMA).calculate(shift);
	 * double[][] awesomeByTimeInterval = indicators.awesome(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, MaType.SMA, 34, MaType.SMA).calculate(from, to);
	 * double[][] awesomeByCandleInterval = indicators.awesome(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, MaType.SMA, 34, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fasterMaTimePeriod FasterMA Time Period
	 * @param fasterMaType FasterMA Type
	 * @param slowerMaTimePeriod SlowerMA Time Period
	 * @param slowerMaType SlowerMA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	@Deprecated
	IIndicatorCalculator<double[], double[][]> awesome(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType);
	
	/**
	 * The Awesome Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] awesome2ByShift = indicators.awesome2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, MaType.SMA, 34, MaType.SMA).calculate(shift);
	 * double[][] awesome2ByTimeInterval = indicators.awesome2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, MaType.SMA, 34, MaType.SMA).calculate(from, to);
	 * double[][] awesome2ByCandleInterval = indicators.awesome2(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 5, MaType.SMA, 34, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fasterMaTimePeriod FasterMA Time Period
	 * @param fasterMaType FasterMA Type
	 * @param slowerMaTimePeriod SlowerMA Time Period
	 * @param slowerMaType SlowerMA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> awesome2(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fasterMaTimePeriod, MaType fasterMaType, int slowerMaTimePeriod, MaType slowerMaType);
	
	/**
	 * The Belt-hold first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlBeltHoldByShift = indicators.cdlBeltHold(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlBeltHoldByTimeInterval = indicators.cdlBeltHold(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlBeltHoldByCandleInterval = indicators.cdlBeltHold(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlBeltHold(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Stochastic first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] stochByShift = indicators.stoch(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA).calculate(shift);
	 * double[][] stochByTimeInterval = indicators.stoch(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA).calculate(from, to);
	 * double[][] stochByCandleInterval = indicators.stoch(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param fastKPeriod Fast %K Period
	 * @param slowKPeriod Slow %K Period
	 * @param slowKMaType Slow %K MAType
	 * @param slowDPeriod Slow %D Period
	 * @param slowDMaType Slow %D MAType
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> stoch(IFeedDescriptor feedDescriptor, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType);
	
	/**
	 * The Butterworth Filter first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double butterworthFilterByShift = indicators.butterworthFilter(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 34).calculate(shift);
	 * double[] butterworthFilterByTimeInterval = indicators.butterworthFilter(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 34).calculate(from, to);
	 * double[] butterworthFilterByCandleInterval = indicators.butterworthFilter(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 34).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> butterworthFilter(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Ichimoku first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] ichimokuByShift = indicators.ichimoku(feedDescriptor, OfferSide.BID, 9, 26, 52).calculate(shift);
	 * double[][] ichimokuByTimeInterval = indicators.ichimoku(feedDescriptor, OfferSide.BID, 9, 26, 52).calculate(from, to);
	 * double[][] ichimokuByCandleInterval = indicators.ichimoku(feedDescriptor, OfferSide.BID, 9, 26, 52).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param tenkan Tenkan
	 * @param kijun Kijun
	 * @param senkou Senkou
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> ichimoku(IFeedDescriptor feedDescriptor, OfferSide side, int tenkan, int kijun, int senkou);
	
	/**
	 * The Normalized Average True Range first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double natrByShift = indicators.natr(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] natrByTimeInterval = indicators.natr(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] natrByCandleInterval = indicators.natr(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> natr(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The On-Neck Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlOnNeckByShift = indicators.cdlOnNeck(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlOnNeckByTimeInterval = indicators.cdlOnNeck(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlOnNeckByCandleInterval = indicators.cdlOnNeck(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlOnNeck(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Rate of change : ((price/prevPrice)-1)*100 first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double rocByShift = indicators.roc(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(shift);
	 * double[] rocByTimeInterval = indicators.roc(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(from, to);
	 * double[] rocByCandleInterval = indicators.roc(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 10).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> roc(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Double Exponential Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double demaByShift = indicators.dema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] demaByTimeInterval = indicators.dema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] demaByCandleInterval = indicators.dema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> dema(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Price Channel first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double prchannelByShift = indicators.prchannel(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] prchannelByTimeInterval = indicators.prchannel(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] prchannelByCandleInterval = indicators.prchannel(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> prchannel(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Exponential Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double emaByShift = indicators.ema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] emaByTimeInterval = indicators.ema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] emaByCandleInterval = indicators.ema(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ema(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The MACD with controllable MA type first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] macdExtByShift = indicators.macdExt(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, MaType.SMA, 26, MaType.SMA, 9, MaType.SMA).calculate(shift);
	 * double[][] macdExtByTimeInterval = indicators.macdExt(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, MaType.SMA, 26, MaType.SMA, 9, MaType.SMA).calculate(from, to);
	 * double[][] macdExtByCandleInterval = indicators.macdExt(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, MaType.SMA, 26, MaType.SMA, 9, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fastPeriod Fast Period
	 * @param fastMaType Fast MAType
	 * @param slowPeriod Slow Period
	 * @param slowMaType Slow MAType
	 * @param signalPeriod Signal Period
	 * @param signalMaType Signal MAType
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> macdExt(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fastPeriod, MaType fastMaType, int slowPeriod, MaType slowMaType, int signalPeriod, MaType signalMaType);
	
	/**
	 * The Williams' %R first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double willrByShift = indicators.willr(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] willrByTimeInterval = indicators.willr(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] willrByCandleInterval = indicators.willr(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> willr(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Vector Trigonometric Tan first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double tanByShift = indicators.tan(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] tanByTimeInterval = indicators.tan(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] tanByCandleInterval = indicators.tan(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> tan(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The MESA Adaptive Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] mamaByShift = indicators.mama(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 0.5, 0.05).calculate(shift);
	 * double[][] mamaByTimeInterval = indicators.mama(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 0.5, 0.05).calculate(from, to);
	 * double[][] mamaByCandleInterval = indicators.mama(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 0.5, 0.05).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fastLimit Fast Limit
	 * @param slowLimit Slow Limit
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> mama(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, double fastLimit, double slowLimit);
	
	/**
	 * The Vector Log Natural first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double lnByShift = indicators.ln(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] lnByTimeInterval = indicators.ln(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] lnByCandleInterval = indicators.ln(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ln(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Aroon first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] aroonByShift = indicators.aroon(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[][] aroonByTimeInterval = indicators.aroon(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[][] aroonByCandleInterval = indicators.aroon(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> aroon(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Rising/Falling Three Methods first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlRiseFall3MethodsByShift = indicators.cdlRiseFall3Methods(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlRiseFall3MethodsByTimeInterval = indicators.cdlRiseFall3Methods(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlRiseFall3MethodsByCandleInterval = indicators.cdlRiseFall3Methods(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlRiseFall3Methods(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Ladder Bottom first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlLadderBottonByShift = indicators.cdlLadderBotton(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlLadderBottonByTimeInterval = indicators.cdlLadderBotton(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlLadderBottonByCandleInterval = indicators.cdlLadderBotton(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlLadderBotton(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Ladder Bottom first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlLadderBottomByShift = indicators.cdlLadderBottom(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlLadderBottomByTimeInterval = indicators.cdlLadderBottom(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlLadderBottomByCandleInterval = indicators.cdlLadderBottom(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlLadderBottom(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Donchian Channel first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] donchianByShift = indicators.donchian(feedDescriptor, OfferSide.BID, 20).calculate(shift);
	 * double[][] donchianByTimeInterval = indicators.donchian(feedDescriptor, OfferSide.BID, 20).calculate(from, to);
	 * double[][] donchianByCandleInterval = indicators.donchian(feedDescriptor, OfferSide.BID, 20).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> donchian(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Moving average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double maByShift = indicators.ma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA).calculate(shift);
	 * double[] maByTimeInterval = indicators.ma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA).calculate(from, to);
	 * double[] maByCandleInterval = indicators.ma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @param maType MA type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, MaType maType);
	
	/**
	 * The Hammer first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHammerByShift = indicators.cdlHammer(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHammerByTimeInterval = indicators.cdlHammer(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHammerByCandleInterval = indicators.cdlHammer(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHammer(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Thrust Bar first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * //Only calculation by shift
	 * double[] tbpByShift = indicators.tbp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> tbp(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Fractal Lines Indicator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] fractalLinesByShift = indicators.fractalLines(feedDescriptor, OfferSide.BID, 2).calculate(shift);
	 * double[][] fractalLinesByTimeInterval = indicators.fractalLines(feedDescriptor, OfferSide.BID, 2).calculate(from, to);
	 * double[][] fractalLinesByCandleInterval = indicators.fractalLines(feedDescriptor, OfferSide.BID, 2).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param barsOnSides bars
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> fractalLines(IFeedDescriptor feedDescriptor, OfferSide side, int barsOnSides);
	
	/**
	 * The APO first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double apoByShift = indicators.apo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, MaType.SMA).calculate(shift);
	 * double[] apoByTimeInterval = indicators.apo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, MaType.SMA).calculate(from, to);
	 * double[] apoByCandleInterval = indicators.apo(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fastPeriod Fast period
	 * @param slowPeriod Slow period
	 * @param maType MA type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> apo(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fastPeriod, int slowPeriod, MaType maType);
	
	/**
	 * The Lowest value over a specified period first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double minByShift = indicators.min(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] minByTimeInterval = indicators.min(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] minByCandleInterval = indicators.min(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> min(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Inverted Hammer first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlInvertedHammerByShift = indicators.cdlInvertedHammer(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlInvertedHammerByTimeInterval = indicators.cdlInvertedHammer(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlInvertedHammerByCandleInterval = indicators.cdlInvertedHammer(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlInvertedHammer(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Thrusting Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlThrustingByShift = indicators.cdlThrusting(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlThrustingByTimeInterval = indicators.cdlThrusting(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlThrustingByCandleInterval = indicators.cdlThrusting(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlThrusting(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Rickshaw Man first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlRickshawManByShift = indicators.cdlRickshawMan(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlRickshawManByTimeInterval = indicators.cdlRickshawMan(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlRickshawManByCandleInterval = indicators.cdlRickshawMan(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlRickshawMan(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Three Stars In The South first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdl3StarsInSouthByShift = indicators.cdl3StarsInSouth(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdl3StarsInSouthByTimeInterval = indicators.cdl3StarsInSouth(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdl3StarsInSouthByCandleInterval = indicators.cdl3StarsInSouth(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdl3StarsInSouth(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Market Facilitation Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] bwmfiByShift = indicators.bwmfi(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] bwmfiByTimeInterval = indicators.bwmfi(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] bwmfiByCandleInterval = indicators.bwmfi(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> bwmfi(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Force Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double forceByShift = indicators.force(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, MaType.SMA).calculate(shift);
	 * double[] forceByTimeInterval = indicators.force(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, MaType.SMA).calculate(from, to);
	 * double[] forceByCandleInterval = indicators.force(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @param maType MA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> force(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, MaType maType);
	
	/**
	 * The Fractal indicator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] fractalByShift = indicators.fractal(feedDescriptor, OfferSide.BID, 2).calculate(shift);
	 * double[][] fractalByTimeInterval = indicators.fractal(feedDescriptor, OfferSide.BID, 2).calculate(from, to);
	 * double[][] fractalByCandleInterval = indicators.fractal(feedDescriptor, OfferSide.BID, 2).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param barsOnSides Number of bars on sides
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> fractal(IFeedDescriptor feedDescriptor, OfferSide side, int barsOnSides);
	
	/**
	 * The Relative Momentum Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double rmiByShift = indicators.rmi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 1).calculate(shift);
	 * double[] rmiByTimeInterval = indicators.rmi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 1).calculate(from, to);
	 * double[] rmiByCandleInterval = indicators.rmi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 1).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @param momentumPeriod MomentumPeriod
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> rmi(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, int momentumPeriod);
	
	/**
	 * The Vector Trigonometric ATan first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double atanByShift = indicators.atan(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] atanByTimeInterval = indicators.atan(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] atanByCandleInterval = indicators.atan(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> atan(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Evening Star first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlEveningStarByShift = indicators.cdlEveningStar(feedDescriptor, OfferSide.BID, 0.3).calculate(shift);
	 * int[] cdlEveningStarByTimeInterval = indicators.cdlEveningStar(feedDescriptor, OfferSide.BID, 0.3).calculate(from, to);
	 * int[] cdlEveningStarByCandleInterval = indicators.cdlEveningStar(feedDescriptor, OfferSide.BID, 0.3).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param penetration Penetration
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlEveningStar(IFeedDescriptor feedDescriptor, OfferSide side, double penetration);
	
	/**
	 * The Hikkake Pattern first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHikkakeByShift = indicators.cdlHikkake(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHikkakeByTimeInterval = indicators.cdlHikkake(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHikkakeByCandleInterval = indicators.cdlHikkake(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHikkake(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Time Segmented Volume first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double tvsByShift = indicators.tvs(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 18).calculate(shift);
	 * double[] tvsByTimeInterval = indicators.tvs(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 18).calculate(from, to);
	 * double[] tvsByCandleInterval = indicators.tvs(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 18).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> tvs(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Fibonacci Pivot first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] fibPivotByShift = indicators.fibPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(shift);
	 * double[][] fibPivotByTimeInterval = indicators.fibPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(from, to);
	 * double[][] fibPivotByCandleInterval = indicators.fibPivot(feedDescriptor, OfferSide.BID, Period.DAILY).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	@Deprecated
	IIndicatorCalculator<double[], double[][]> fibPivot(IFeedDescriptor feedDescriptor, OfferSide side, Period timePeriod);
	
	/**
	 * The Fibonacci Pivot first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] fibPivot2ByShift = indicators.fibPivot2(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] fibPivot2ByTimeInterval = indicators.fibPivot2(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] fibPivot2ByCandleInterval = indicators.fibPivot2(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> fibPivot2(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Kaufman Adaptive Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double kamaByShift = indicators.kama(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, 2, 30).calculate(shift);
	 * double[] kamaByTimeInterval = indicators.kama(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, 2, 30).calculate(from, to);
	 * double[] kamaByCandleInterval = indicators.kama(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, 2, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @param fastMAPeriod Fast MA period
	 * @param slowMAPeriod Slow MA period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> kama(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, int fastMAPeriod, int slowMAPeriod);
	
	/**
	 * The Lowest and highest values over a specified period first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] minMaxByShift = indicators.minMax(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[][] minMaxByTimeInterval = indicators.minMax(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[][] minMaxByCandleInterval = indicators.minMax(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> minMax(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Weighted Close Price first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double wclPriceByShift = indicators.wclPrice(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] wclPriceByTimeInterval = indicators.wclPrice(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] wclPriceByCandleInterval = indicators.wclPrice(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> wclPrice(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Upside/Downside Gap Three Methods first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlXsideGap3MethodsByShift = indicators.cdlXsideGap3Methods(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlXsideGap3MethodsByTimeInterval = indicators.cdlXsideGap3Methods(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlXsideGap3MethodsByCandleInterval = indicators.cdlXsideGap3Methods(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlXsideGap3Methods(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Hilbert Transform - Trend vs Cycle Mode first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int ht_trendmodeByShift = indicators.ht_trendmode(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * int[] ht_trendmodeByTimeInterval = indicators.ht_trendmode(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * int[] ht_trendmodeByCandleInterval = indicators.ht_trendmode(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> ht_trendmode(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The World Stock Market Time first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * Object[] wsmTimeByShift = indicators.wsmTime(feedDescriptor, OfferSide.BID).calculate(shift);
	 * Object[] wsmTimeByTimeInterval = indicators.wsmTime(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * Object[] wsmTimeByCandleInterval = indicators.wsmTime(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Object[], Object[]> wsmTime(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vector Trigonometric Sinh first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double sinhByShift = indicators.sinh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] sinhByTimeInterval = indicators.sinh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] sinhByCandleInterval = indicators.sinh(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sinh(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Typical Price first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double typPriceByShift = indicators.typPrice(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[] typPriceByTimeInterval = indicators.typPrice(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[] typPriceByCandleInterval = indicators.typPrice(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> typPrice(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Homing Pigeon first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlHomingPigeonByShift = indicators.cdlHomingPigeon(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlHomingPigeonByTimeInterval = indicators.cdlHomingPigeon(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlHomingPigeonByCandleInterval = indicators.cdlHomingPigeon(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlHomingPigeon(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Long Line Candle first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlLongLineByShift = indicators.cdlLongLine(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlLongLineByTimeInterval = indicators.cdlLongLine(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlLongLineByCandleInterval = indicators.cdlLongLine(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlLongLine(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vector Arithmetic Exp first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double expByShift = indicators.exp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] expByTimeInterval = indicators.exp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] expByCandleInterval = indicators.exp(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> exp(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Evening Doji Star first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlEveningDojiStarByShift = indicators.cdlEveningDojiStar(feedDescriptor, OfferSide.BID, 0.3).calculate(shift);
	 * int[] cdlEveningDojiStarByTimeInterval = indicators.cdlEveningDojiStar(feedDescriptor, OfferSide.BID, 0.3).calculate(from, to);
	 * int[] cdlEveningDojiStarByCandleInterval = indicators.cdlEveningDojiStar(feedDescriptor, OfferSide.BID, 0.3).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param penetration Penetration
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlEveningDojiStar(IFeedDescriptor feedDescriptor, OfferSide side, double penetration);
	
	/**
	 * The Moving Average Covergence/Divergence first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] macdByShift = indicators.macd(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(shift);
	 * double[][] macdByTimeInterval = indicators.macd(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(from, to);
	 * double[][] macdByCandleInterval = indicators.macd(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param fastPeriod Fast Period
	 * @param slowPeriod Slow Period
	 * @param signalPeriod Signal Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> macd(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int fastPeriod, int slowPeriod, int signalPeriod);
	
	/**
	 * The Long Legged Doji first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlLongLeggedDojiByShift = indicators.cdlLongLeggedDoji(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlLongLeggedDojiByTimeInterval = indicators.cdlLongLeggedDoji(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlLongLeggedDojiByCandleInterval = indicators.cdlLongLeggedDoji(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlLongLeggedDoji(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Hilbert Transform - Phasor Components first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] ht_phasorByShift = indicators.ht_phasor(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[][] ht_phasorByTimeInterval = indicators.ht_phasor(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[][] ht_phasorByCandleInterval = indicators.ht_phasor(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> ht_phasor(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The EMA Envelope first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] emaEnvelopeByShift = indicators.emaEnvelope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 0.1).calculate(shift);
	 * double[][] emaEnvelopeByTimeInterval = indicators.emaEnvelope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 0.1).calculate(from, to);
	 * double[][] emaEnvelopeByCandleInterval = indicators.emaEnvelope(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14, 0.1).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @param deviation Deviation
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> emaEnvelope(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, double deviation);
	
	/**
	 * The Heikin Ashi first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] heikinAshiByShift = indicators.heikinAshi(feedDescriptor, OfferSide.BID).calculate(shift);
	 * double[][] heikinAshiByTimeInterval = indicators.heikinAshi(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * double[][] heikinAshiByCandleInterval = indicators.heikinAshi(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> heikinAshi(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Bollinger Bands first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] bbandsByShift = indicators.bbands(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 2.0, 2.0, MaType.EMA).calculate(shift);
	 * double[][] bbandsByTimeInterval = indicators.bbands(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 2.0, 2.0, MaType.EMA).calculate(from, to);
	 * double[][] bbandsByCandleInterval = indicators.bbands(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 2.0, 2.0, MaType.EMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @param nbDevUp Nb Dev Up
	 * @param nbDevDn Nb Dev Dn
	 * @param maType MA type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> bbands(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, double nbDevUp, double nbDevDn, MaType maType);
	
	/**
	 * The Hilbert Transform - Dominant Cycle Phase first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ht_dcphaseByShift = indicators.ht_dcphase(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] ht_dcphaseByTimeInterval = indicators.ht_dcphase(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] ht_dcphaseByCandleInterval = indicators.ht_dcphase(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ht_dcphase(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Vector Arithmetic Add first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double addByShift = indicators.add(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] addByTimeInterval = indicators.add(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] addByCandleInterval = indicators.add(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> add(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2);
	
	/**
	 * The Kairi first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double kairiByShift = indicators.kairi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA).calculate(shift);
	 * double[] kairiByTimeInterval = indicators.kairi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA).calculate(from, to);
	 * double[] kairiByCandleInterval = indicators.kairi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time period
	 * @param maType MA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> kairi(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod, MaType maType);
	
	/**
	 * The Murrey Channels first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] murrey2ByShift = indicators.murrey2(feedDescriptor, OfferSide.BID, 90, 0).calculate(shift);
	 * double[][] murrey2ByTimeInterval = indicators.murrey2(feedDescriptor, OfferSide.BID, 90, 0).calculate(from, to);
	 * double[][] murrey2ByCandleInterval = indicators.murrey2(feedDescriptor, OfferSide.BID, 90, 0).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param nPeriod N Period
	 * @param stepBack Step Back
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> murrey2(IFeedDescriptor feedDescriptor, OfferSide side, int nPeriod, int stepBack);
	
	/**
	 * The Average True Range first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double atrByShift = indicators.atr(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] atrByTimeInterval = indicators.atr(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] atrByCandleInterval = indicators.atr(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> atr(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Alligator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] alligatorByShift = indicators.alligator(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 8, 5).calculate(shift);
	 * double[][] alligatorByTimeInterval = indicators.alligator(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 8, 5).calculate(from, to);
	 * double[][] alligatorByCandleInterval = indicators.alligator(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 8, 5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param jawTimePeriod Jaw Time Period
	 * @param teethTimePeriod Teeth Time Period
	 * @param lipsTimePeriod Lips Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> alligator(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int jawTimePeriod, int teethTimePeriod, int lipsTimePeriod);
	
	/**
	 * The Average Directional Movement Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double adxByShift = indicators.adx(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] adxByTimeInterval = indicators.adx(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] adxByCandleInterval = indicators.adx(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> adx(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Three Advancing White Soldiers first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdl3WhiteSoldiersByShift = indicators.cdl3WhiteSoldiers(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdl3WhiteSoldiersByTimeInterval = indicators.cdl3WhiteSoldiers(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdl3WhiteSoldiersByCandleInterval = indicators.cdl3WhiteSoldiers(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdl3WhiteSoldiers(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vector Trigonometric ACos first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double acosByShift = indicators.acos(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] acosByTimeInterval = indicators.acos(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] acosByCandleInterval = indicators.acos(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> acos(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Tasuki Gap first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlTasukiGapByShift = indicators.cdlTasukiGap(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlTasukiGapByTimeInterval = indicators.cdlTasukiGap(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlTasukiGapByCandleInterval = indicators.cdlTasukiGap(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlTasukiGap(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Three Outside Up/Down first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdl3OutsideByShift = indicators.cdl3Outside(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdl3OutsideByTimeInterval = indicators.cdl3Outside(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdl3OutsideByCandleInterval = indicators.cdl3Outside(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdl3Outside(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Dragonfly Doji first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlDragonflyDojiByShift = indicators.cdlDragonflyDoji(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlDragonflyDojiByTimeInterval = indicators.cdlDragonflyDoji(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlDragonflyDojiByCandleInterval = indicators.cdlDragonflyDoji(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlDragonflyDoji(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Aroon Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double aroonOscByShift = indicators.aroonOsc(feedDescriptor, OfferSide.BID, 14).calculate(shift);
	 * double[] aroonOscByTimeInterval = indicators.aroonOsc(feedDescriptor, OfferSide.BID, 14).calculate(from, to);
	 * double[] aroonOscByCandleInterval = indicators.aroonOsc(feedDescriptor, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> aroonOsc(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod);
	
	/**
	 * The Heikin Ashi with a single candle output first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * IBar heikinAshiSingleByShift = indicators.heikinAshiSingle(feedDescriptor, OfferSide.BID).calculate(shift);
	 * IBar[] heikinAshiSingleByTimeInterval = indicators.heikinAshiSingle(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * IBar[] heikinAshiSingleByCandleInterval = indicators.heikinAshiSingle(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<IBar, IBar[]> heikinAshiSingle(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Vector Log10 first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double log10ByShift = indicators.log10(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] log10ByTimeInterval = indicators.log10(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] log10ByCandleInterval = indicators.log10(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> log10(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side);
	
	/**
	 * The Linear Regression first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double linearRegByShift = indicators.linearReg(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(shift);
	 * double[] linearRegByTimeInterval = indicators.linearReg(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(from, to);
	 * double[] linearRegByCandleInterval = indicators.linearReg(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 14).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> linearReg(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Simple Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double smaByShift = indicators.sma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(shift);
	 * double[] smaByTimeInterval = indicators.sma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(from, to);
	 * double[] smaByCandleInterval = indicators.sma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 30).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Abandoned Baby first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlAbandonedBabyByShift = indicators.cdlAbandonedBaby(feedDescriptor, OfferSide.BID, 0.3).calculate(shift);
	 * int[] cdlAbandonedBabyByTimeInterval = indicators.cdlAbandonedBaby(feedDescriptor, OfferSide.BID, 0.3).calculate(from, to);
	 * int[] cdlAbandonedBabyByCandleInterval = indicators.cdlAbandonedBaby(feedDescriptor, OfferSide.BID, 0.3).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param penetration Penetration
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlAbandonedBaby(IFeedDescriptor feedDescriptor, OfferSide side, double penetration);
	
	/**
	 * The Ultimate Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double ultOscByShift = indicators.ultOsc(feedDescriptor, OfferSide.BID, 7, 14, 28).calculate(shift);
	 * double[] ultOscByTimeInterval = indicators.ultOsc(feedDescriptor, OfferSide.BID, 7, 14, 28).calculate(from, to);
	 * double[] ultOscByCandleInterval = indicators.ultOsc(feedDescriptor, OfferSide.BID, 7, 14, 28).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod1 Time Period 1
	 * @param timePeriod2 Time Period 2
	 * @param timePeriod3 Time Period 3
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> ultOsc(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod1, int timePeriod2, int timePeriod3);
	
	/**
	 * The Stochastic Momentum Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] smiByShift = indicators.smi(feedDescriptor, OfferSide.BID, 2, 5, 8, 5).calculate(shift);
	 * double[][] smiByTimeInterval = indicators.smi(feedDescriptor, OfferSide.BID, 2, 5, 8, 5).calculate(from, to);
	 * double[][] smiByCandleInterval = indicators.smi(feedDescriptor, OfferSide.BID, 2, 5, 8, 5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param fastKPeriod fastKPeriod
	 * @param slowKPeriod slowKPeriod
	 * @param slowDPeriod slowDPeriod
	 * @param smoothingPeriod SmoothingPeriod
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> smi(IFeedDescriptor feedDescriptor, OfferSide side, int fastKPeriod, int slowKPeriod, int slowDPeriod, int smoothingPeriod);
	
	/**
	 * The Hull Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double hmaByShift = indicators.hma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 15).calculate(shift);
	 * double[] hmaByTimeInterval = indicators.hma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 15).calculate(from, to);
	 * double[] hmaByCandleInterval = indicators.hma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 15).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod Time Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> hma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int timePeriod);
	
	/**
	 * The Short Line Candle first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * int cdlShortLineByShift = indicators.cdlShortLine(feedDescriptor, OfferSide.BID).calculate(shift);
	 * int[] cdlShortLineByTimeInterval = indicators.cdlShortLine(feedDescriptor, OfferSide.BID).calculate(from, to);
	 * int[] cdlShortLineByCandleInterval = indicators.cdlShortLine(feedDescriptor, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Integer, int[]> cdlShortLine(IFeedDescriptor feedDescriptor, OfferSide side);
	
	/**
	 * The Heikin Ashi Smoothed Lines first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] heikinAshiSmoothByShift = indicators.heikinAshiSmooth(feedDescriptor, OfferSide.BID, 11, MaType.KAMA, 10, MaType.WMA).calculate(shift);
	 * double[][] heikinAshiSmoothByTimeInterval = indicators.heikinAshiSmooth(feedDescriptor, OfferSide.BID, 11, MaType.KAMA, 10, MaType.WMA).calculate(from, to);
	 * double[][] heikinAshiSmoothByCandleInterval = indicators.heikinAshiSmooth(feedDescriptor, OfferSide.BID, 11, MaType.KAMA, 10, MaType.WMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param timePeriod MA Type
	 * @param maType MA Period
	 * @param secondaryTimePeriod Secondary MA Type
	 * @param secondaryMAType Secondary MA Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> heikinAshiSmooth(IFeedDescriptor feedDescriptor, OfferSide side, int timePeriod, MaType maType, int secondaryTimePeriod, MaType secondaryMAType);
	
	/**
	 * The Parabolic SAR first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double sarByShift = indicators.sar(feedDescriptor, OfferSide.BID, 0.02, 0.2).calculate(shift);
	 * double[] sarByTimeInterval = indicators.sar(feedDescriptor, OfferSide.BID, 0.02, 0.2).calculate(from, to);
	 * double[] sarByCandleInterval = indicators.sar(feedDescriptor, OfferSide.BID, 0.02, 0.2).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param acceleration Acceleration
	 * @param maximum Maximum
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sar(IFeedDescriptor feedDescriptor, OfferSide side, double acceleration, double maximum);
	
	/**
	 * The Parabolic SAR - Extended first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double sarExtByShift = indicators.sarExt(feedDescriptor, OfferSide.BID, 0.0, 0.0, 0.02, 0.02, 0.2, 0.02, 0.02, 0.2).calculate(shift);
	 * double[] sarExtByTimeInterval = indicators.sarExt(feedDescriptor, OfferSide.BID, 0.0, 0.0, 0.02, 0.02, 0.2, 0.02, 0.02, 0.2).calculate(from, to);
	 * double[] sarExtByCandleInterval = indicators.sarExt(feedDescriptor, OfferSide.BID, 0.0, 0.0, 0.02, 0.02, 0.2, 0.02, 0.02, 0.2).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param startValue Start Value
	 * @param offsetOnReverse Offset On Reverse
	 * @param accelerationInitLong Acceleration Init Long
	 * @param accelerationLong Acceleration Long
	 * @param accelerationMaxLong Acceleration Max Long
	 * @param accelerationInitShort Acceleration Init Short
	 * @param accelerationShort Acceleration Short
	 * @param accelerationMaxShort Acceleration Max Short
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> sarExt(IFeedDescriptor feedDescriptor, OfferSide side, double startValue, double offsetOnReverse, double accelerationInitLong, double accelerationLong, double accelerationMaxLong, double accelerationInitShort, double accelerationShort, double accelerationMaxShort);
	
	/**
	 * The Regression Channel first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] regrChannelByShift = indicators.regrChannel(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 3, 2.0, 250).calculate(shift);
	 * double[][] regrChannelByTimeInterval = indicators.regrChannel(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 3, 2.0, 250).calculate(from, to);
	 * double[][] regrChannelByCandleInterval = indicators.regrChannel(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 3, 2.0, 250).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param degree Degree
	 * @param kstd Kstd
	 * @param bars Bars
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> regrChannel(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int degree, double kstd, int bars);
	
	/**
	 * The Vector Arithmetic Div first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double divByShift = indicators.div(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] divByTimeInterval = indicators.div(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] divByCandleInterval = indicators.div(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> div(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2);
	
	/**
	 * The Guppy Multiple Moving Average first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] gmmaByShift = indicators.gmma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 3, 5, 8, 10, 12, 15, 30, 35, 40, 45, 50, 60).calculate(shift);
	 * double[][] gmmaByTimeInterval = indicators.gmma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 3, 5, 8, 10, 12, 15, 30, 35, 40, 45, 50, 60).calculate(from, to);
	 * double[][] gmmaByCandleInterval = indicators.gmma(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 3, 5, 8, 10, 12, 15, 30, 35, 40, 45, 50, 60).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param shortEMA1Period Short EMA1 Period
	 * @param shortEMA2Period Short EMA2 Period
	 * @param shortEMA3Period Short EMA3 Period
	 * @param shortEMA4Period Short EMA4 Period
	 * @param shortEMA5Period Short EMA5 Period
	 * @param shortEMA6Period Short EMA6 Period
	 * @param longEMA1Period Long EMA1 Period
	 * @param longEMA2Period Long EMA2 Period
	 * @param longEMA3Period Long EMA3 Period
	 * @param longEMA4Period Long EMA4 Period
	 * @param longEMA5Period Long EMA5 Period
	 * @param longEMA6Period Long EMA6 Period
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> gmma(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int shortEMA1Period, int shortEMA2Period, int shortEMA3Period, int shortEMA4Period, int shortEMA5Period, int shortEMA6Period, int longEMA1Period, int longEMA2Period, int longEMA3Period, int longEMA4Period, int longEMA5Period, int longEMA6Period);
	
	/**
	 * The Vector Arithmetic Mult first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double multByShift = indicators.mult(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(shift);
	 * double[] multByTimeInterval = indicators.mult(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(from, to);
	 * double[] multByCandleInterval = indicators.mult(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, AppliedPrice.CLOSE, OfferSide.BID).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice1 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side1 Bid or Ask side for tick feeds
	 * @param appliedPrice2 {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side2 Bid or Ask side for tick feeds
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> mult(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice1, OfferSide side1, AppliedPrice appliedPrice2, OfferSide side2);
	
	/**
	 * The True Strength Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] tsiByShift = indicators.tsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 13, 7).calculate(shift);
	 * double[][] tsiByTimeInterval = indicators.tsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 13, 7).calculate(from, to);
	 * double[][] tsiByCandleInterval = indicators.tsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 13, 7).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param smoothingPeriods Smoothing Periods
	 * @param doubleSmoothingPeriods Double Smoothing Periods
	 * @param signalLinePeriods Signal Line Periods
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> tsi(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int smoothingPeriods, int doubleSmoothingPeriods, int signalLinePeriods);
	
	/**
	 * The Traders Dynamic Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] tdiByShift = indicators.tdi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 2, MaType.SMA, 7, MaType.SMA, 34, MaType.SMA).calculate(shift);
	 * double[][] tdiByTimeInterval = indicators.tdi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 2, MaType.SMA, 7, MaType.SMA, 34, MaType.SMA).calculate(from, to);
	 * double[][] tdiByCandleInterval = indicators.tdi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 13, 2, MaType.SMA, 7, MaType.SMA, 34, MaType.SMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param rsiPeriod RSI Period
	 * @param rsiPriceLine RSI Price Line
	 * @param priceMAType Price MA Type
	 * @param tradeSignalLine Trade Signal Line
	 * @param signalMAType Signal MA Type
	 * @param volatilityBand Volatility Band
	 * @param volatilityMAType Volatility MA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> tdi(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int rsiPeriod, int rsiPriceLine, MaType priceMAType, int tradeSignalLine, MaType signalMAType, int volatilityBand, MaType volatilityMAType);
	
	/**
	 * The Ehlers Laguerre Relative Strength Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double lrsiByShift = indicators.lrsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 0.5).calculate(shift);
	 * double[] lrsiByTimeInterval = indicators.lrsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 0.5).calculate(from, to);
	 * double[] lrsiByCandleInterval = indicators.lrsi(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 0.5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param dampingFactor Damping Factor
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> lrsi(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, double dampingFactor);
	
	/**
	 * The McClellan Oscillator first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double mcclOscByShift = indicators.mcclOsc(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, MaType.EMA).calculate(shift);
	 * double[] mcclOscByTimeInterval = indicators.mcclOsc(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, MaType.EMA).calculate(from, to);
	 * double[] mcclOscByCandleInterval = indicators.mcclOsc(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, MaType.EMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param shortMAPeriods Short MA Periods
	 * @param longMAPeriods Long MA Periods
	 * @param maType MA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> mcclOsc(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int shortMAPeriods, int longMAPeriods, MaType maType);
	
	/**
	 * The McClellan Histogram first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double mcclHistByShift = indicators.mcclHist(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, 9, MaType.EMA).calculate(shift);
	 * double[] mcclHistByTimeInterval = indicators.mcclHist(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, 9, MaType.EMA).calculate(from, to);
	 * double[] mcclHistByCandleInterval = indicators.mcclHist(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, 9, MaType.EMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param shortMAPeriods Short MA Periods
	 * @param longMAPeriods Long MA Periods
	 * @param signalMAPeriods Signal MA Periods
	 * @param maType MA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> mcclHist(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int shortMAPeriods, int longMAPeriods, int signalMAPeriods, MaType maType);
	
	/**
	 * The McClellan Summation Index first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double mcclSumByShift = indicators.mcclSum(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, MaType.EMA).calculate(shift);
	 * double[] mcclSumByTimeInterval = indicators.mcclSum(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, MaType.EMA).calculate(from, to);
	 * double[] mcclSumByCandleInterval = indicators.mcclSum(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 19, 39, MaType.EMA).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param shortMAPeriods Short MA Periods
	 * @param longMAPeriods Long MA Periods
	 * @param maType MA Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<Double, double[]> mcclSum(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int shortMAPeriods, int longMAPeriods, MaType maType);
	
	/**
	 * The Stochastic first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] stochPByShift = indicators.stochP(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA, 0).calculate(shift);
	 * double[][] stochPByTimeInterval = indicators.stochP(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA, 0).calculate(from, to);
	 * double[][] stochPByCandleInterval = indicators.stochP(feedDescriptor, OfferSide.BID, 5, 3, MaType.SMA, 3, MaType.SMA, 0).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param side Bid or Ask side for tick feeds
	 * @param fastKPeriod Fast %K Period
	 * @param slowKPeriod Slow %K Period
	 * @param slowKMaType Slow %K MAType
	 * @param slowDPeriod Slow %D Period
	 * @param slowDMaType Slow %D MAType
	 * @param priceType Price Type
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> stochP(IFeedDescriptor feedDescriptor, OfferSide side, int fastKPeriod, int slowKPeriod, MaType slowKMaType, int slowDPeriod, MaType slowDMaType, int priceType);
	
	/**
	 * The Keltner Bands (Based on ATR) first calculation step. 
	 * <p>Consider multiple usage examples: 
	 *
	 * <pre>{@code 
	 * double[] kbandsByShift = indicators.kbands(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 10, 2.5).calculate(shift);
	 * double[][] kbandsByTimeInterval = indicators.kbands(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 10, 2.5).calculate(from, to);
	 * double[][] kbandsByCandleInterval = indicators.kbands(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 20, 10, 2.5).calculate(10, time, 0);
	 * }</pre>
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrice {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param side Bid or Ask side for tick feeds
	 * @param emaPeriod EMA Periods
	 * @param atrPeriod ATR Periods
	 * @param multiplier ATR Multiple
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	IIndicatorCalculator<double[], double[][]> kbands(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide side, int emaPeriod, int atrPeriod, double multiplier);
	
	//ON-FEED METHODS END
	
	/**
	 * The custom indicator first calculation step. 
	 * <p>Consider defining a custom indicator and afterwards using it: 
	 *
	 * <pre>{@code
	 * IIndicatorCalculator<double[], double[][]> customMacd(IFeedDescriptor feedDescriptor, AppliedPrice appliedPrice, OfferSide offerSide, int fastPeriod, int slowPeriod, int signalPeriod) {
	 *     return indicators.custom("MACD", double[].class, double[][].class, feedDescriptor, new AppliedPrice[] { appliedPrice }, new OfferSide[] { offerSide }, new Object[] { fastPeriod, slowPeriod, signalPeriod });
	 * }
	 * 
	 * double[] customByShift = customMacd(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(shift);
	 * double[][] customByTimeInterval = customMacd(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(from, to);
	 * double[][] customByCandleInterval = customMacd(feedDescriptor, AppliedPrice.CLOSE, OfferSide.BID, 12, 26, 9).calculate(10, time, 0);
	 * }</pre>
     *
     * @param <T> output for calculation by shift
     * @param <U> output for calculation by candle or time interval
	 * @param indName custom indicator name
	 * @param classShift class for by-shift calculation
	 * @param classArr class for by time interval and by candle interval calculations
	 * @param feedDescriptor feed descriptor {@link IFeedDescriptor} which will be used to calculate indicator
	 * @param appliedPrices {@link IIndicators.AppliedPrice type} for bar-based feeds (i.e., all but ticks)
	 * @param offerSides Bid or Ask sides for tick feeds
	 * @param optInputs optional inputs
	 * @return {@link IIndicatorCalculator} object to be used for the second calculation step
	 * @see <a href = http://www.dukascopy.com/wiki/#Indicator_calculation/Universal_price_feed>Indicator calculation on feed</a>
	 */
	<T, U> IIndicatorCalculator<T, U> custom(String indName, Class<T> classShift, Class<U> classArr, IFeedDescriptor feedDescriptor, AppliedPrice[] appliedPrices, OfferSide[] offerSides, Object[] optInputs);

}
